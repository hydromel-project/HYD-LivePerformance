<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game HUD - Playrate Challenge</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');

    :root {
      --bg-color: #0a0a12;
      --neon-blue: #00f0ff;
      --neon-pink: #ff00ff;
      --neon-green: #00ff88;
      --neon-yellow: #ffff00;
      --neon-orange: #ff8800;
      --neon-red: #ff0044;
      --ice-blue: #88ddff;
      --fire-orange: #ff4400;
      --ui-dark: #1a1a2e;
      --ui-border: #333355;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; }

    body {
      background: var(--bg-color);
      font-family: 'Orbitron', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      perspective: 1000px;
    }

    body.transparent-bg { background: transparent !important; }

    /* Scanlines overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.1) 2px,
        rgba(0, 0, 0, 0.1) 4px
      );
      pointer-events: none;
      z-index: 1000;
    }

    body.no-scanlines::before { display: none; }

    /* Screen shake */
    @keyframes shake {
      0%, 100% { transform: translateX(0) translateY(0); }
      10% { transform: translateX(-10px) translateY(-5px); }
      20% { transform: translateX(10px) translateY(5px); }
      30% { transform: translateX(-8px) translateY(-3px); }
      40% { transform: translateX(8px) translateY(3px); }
      50% { transform: translateX(-5px) translateY(-2px); }
      60% { transform: translateX(5px) translateY(2px); }
      70% { transform: translateX(-3px) translateY(-1px); }
      80% { transform: translateX(3px) translateY(1px); }
      90% { transform: translateX(-1px) translateY(0); }
    }

    .shake { animation: shake 0.5s ease-out; }

    /* Main container */
    .hud-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      max-width: 1000px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      grid-template-rows: auto auto auto;
      gap: 10px;
      padding: 10px;
      z-index: 10;
    }

    /* Settings toggle */
    .settings-toggle {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 201;
      background: var(--ui-dark);
      color: var(--neon-blue);
      border: 2px solid var(--neon-blue);
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      text-transform: uppercase;
      box-shadow: 0 0 10px var(--neon-blue);
    }
    .settings-toggle:hover { background: var(--neon-blue); color: var(--bg-color); }
    .settings-toggle.hidden { display: none; }

    /* Settings Panel */
    .settings-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 350px;
      height: 100%;
      background: var(--ui-dark);
      border-right: 2px solid var(--neon-blue);
      z-index: 200;
      padding: 20px;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      box-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
    }
    .settings-panel.open { transform: translateX(0); }
    .settings-panel.hidden { display: none; }

    .settings-panel h2 {
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      color: var(--neon-pink);
      margin-bottom: 20px;
      text-shadow: 0 0 10px var(--neon-pink);
    }

    .settings-panel h3 {
      font-size: 10px;
      color: var(--neon-blue);
      margin: 20px 0 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .settings-group {
      margin-bottom: 15px;
    }

    .settings-group label {
      display: block;
      font-size: 10px;
      color: #888;
      margin-bottom: 5px;
      text-transform: uppercase;
    }

    .settings-group select,
    .settings-group input[type="number"],
    .settings-group input[type="color"] {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--ui-border);
      border-radius: 4px;
      background: var(--bg-color);
      color: var(--neon-green);
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
    }

    .settings-group input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      color: #ccc;
      font-size: 11px;
    }
    .checkbox-label input { margin-right: 10px; }

    .btn-row {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .btn-row button {
      flex: 1;
      padding: 10px;
      border: 2px solid;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      text-transform: uppercase;
    }

    .btn-save {
      background: transparent;
      border-color: var(--neon-green);
      color: var(--neon-green);
    }
    .btn-save:hover { background: var(--neon-green); color: var(--bg-color); }

    .btn-reset {
      background: transparent;
      border-color: var(--neon-red);
      color: var(--neon-red);
    }
    .btn-reset:hover { background: var(--neon-red); color: var(--bg-color); }

    /* ============ TOP SECTION ============ */
    .top-section {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 15px;
      background: linear-gradient(180deg, rgba(0,240,255,0.1) 0%, transparent 100%);
      border-bottom: 2px solid var(--neon-blue);
    }

    .bpm-display, .tempo-display {
      text-align: center;
    }

    .bpm-label, .tempo-label {
      font-size: 8px;
      color: var(--neon-blue);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .bpm-value {
      font-size: 32px;
      font-weight: 900;
      color: var(--neon-pink);
      text-shadow:
        0 0 10px var(--neon-pink),
        0 0 20px var(--neon-pink);
      line-height: 1;
    }

    .tempo-value {
      font-size: 40px;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow:
        0 0 10px var(--neon-green),
        0 0 20px var(--neon-green);
      line-height: 1;
      transition: color 0.3s ease;
    }

    .tempo-value.fast {
      color: var(--fire-orange);
      text-shadow:
        0 0 10px var(--fire-orange),
        0 0 20px var(--fire-orange);
    }

    .tempo-value.slow {
      color: var(--ice-blue);
      text-shadow:
        0 0 10px var(--ice-blue),
        0 0 20px var(--ice-blue);
    }

    .time-sig-display {
      font-family: 'Press Start 2P', monospace;
      font-size: 18px;
      color: var(--neon-green);
      text-shadow: 0 0 10px var(--neon-green);
      padding: 8px 15px;
      border: 2px solid var(--neon-green);
      border-radius: 6px;
      background: rgba(0, 255, 136, 0.1);
    }

    /* ============ CENTER - PLAYRATE GAUGE ============ */
    .center-section {
      grid-column: 2;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      position: relative;
      padding-top: 5px;
    }

    .gauge-container {
      position: relative;
      width: 280px;
      height: 160px;
    }

    .gauge-svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    .gauge-bg {
      fill: none;
      stroke: var(--ui-dark);
      stroke-width: 20;
      stroke-linecap: round;
    }

    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.3s ease, stroke 0.3s ease;
      filter: drop-shadow(0 0 10px currentColor);
    }

    .gauge-ticks text {
      fill: #666;
      font-size: 12px;
      font-family: 'Orbitron', sans-serif;
    }

    .gauge-needle {
      fill: var(--neon-pink);
      filter: drop-shadow(0 0 10px var(--neon-pink));
      transform-origin: 175px 180px;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .gauge-center-dot {
      fill: var(--neon-blue);
      filter: drop-shadow(0 0 15px var(--neon-blue));
    }

    /* Playrate number display */
    .playrate-display {
      position: absolute;
      bottom: -20px;
      text-align: center;
      width: 100%;
    }

    .playrate-value {
      font-size: 48px;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow:
        0 0 10px currentColor,
        0 0 20px currentColor;
      transition: color 0.3s ease, transform 0.1s ease;
    }

    .playrate-value.speed-up {
      color: var(--fire-orange);
      animation: pulseUp 0.3s ease;
    }

    .playrate-value.slow-down {
      color: var(--ice-blue);
      animation: pulseDown 0.3s ease;
    }

    @keyframes pulseUp {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @keyframes pulseDown {
      0% { transform: scale(1); }
      50% { transform: scale(0.9); }
      100% { transform: scale(1); }
    }

    .playrate-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-top: 3px;
    }

    /* Speed/Slow indicators */
    .speed-indicator {
      position: absolute;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s ease;
      text-shadow: 0 0 15px currentColor;
    }

    .speed-indicator.fast {
      top: 10px;
      right: -60px;
      color: var(--fire-orange);
    }

    .speed-indicator.slow {
      top: 10px;
      left: -60px;
      color: var(--ice-blue);
    }

    .speed-indicator.active { opacity: 1; }

    /* ============ LEFT - BEAT INDICATOR ============ */
    .left-section {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      gap: 10px;
      padding-top: 10px;
    }

    .beat-ring-container {
      position: relative;
      width: 100px;
      height: 100px;
    }

    .beat-ring {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid var(--ui-border);
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle, rgba(0,240,255,0.1) 0%, transparent 70%);
      transition: border-color 0.1s ease, box-shadow 0.1s ease;
    }

    .beat-ring.pulse {
      border-color: var(--neon-blue);
      box-shadow:
        0 0 20px var(--neon-blue),
        0 0 40px var(--neon-blue),
        inset 0 0 30px rgba(0, 240, 255, 0.3);
    }

    .beat-ring.downbeat {
      border-color: var(--neon-pink);
      box-shadow:
        0 0 30px var(--neon-pink),
        0 0 60px var(--neon-pink),
        inset 0 0 40px rgba(255, 0, 255, 0.3);
    }

    .beat-number {
      font-family: 'Press Start 2P', monospace;
      font-size: 32px;
      color: var(--neon-blue);
      text-shadow: 0 0 15px var(--neon-blue);
      transition: color 0.1s ease, transform 0.05s ease;
    }

    .beat-ring.pulse .beat-number {
      transform: scale(1.1);
    }

    .beat-ring.downbeat .beat-number {
      color: var(--neon-pink);
      text-shadow: 0 0 30px var(--neon-pink);
      transform: scale(1.2);
    }

    /* Beat dots */
    .beat-dots {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }

    .beat-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--ui-dark);
      border: 2px solid var(--ui-border);
      transition: all 0.1s ease;
    }

    .beat-dot.active {
      background: var(--neon-blue);
      border-color: var(--neon-blue);
      box-shadow: 0 0 10px var(--neon-blue);
    }

    .beat-dot.downbeat-dot {
      width: 18px;
      height: 18px;
    }

    .beat-dot.downbeat-dot.active {
      background: var(--neon-pink);
      border-color: var(--neon-pink);
      box-shadow: 0 0 15px var(--neon-pink);
    }

    /* ============ RIGHT - CHANGE FEED ============ */
    .right-section {
      display: flex;
      flex-direction: column;
      gap: 5px;
      padding-top: 5px;
      max-height: 200px;
      overflow: hidden;
    }

    .feed-title {
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      color: var(--neon-pink);
      text-transform: uppercase;
      letter-spacing: 2px;
      padding-bottom: 5px;
      border-bottom: 1px solid var(--ui-border);
      flex-shrink: 0;
    }

    .change-feed {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 180px;
    }

    .feed-item {
      background: var(--ui-dark);
      border-left: 3px solid var(--neon-blue);
      padding: 8px 10px;
      border-radius: 0 6px 6px 0;
      animation: slideIn 0.3s ease;
      font-size: 10px;
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }

    .feed-item.speed-up { border-color: var(--fire-orange); }
    .feed-item.slow-down { border-color: var(--ice-blue); }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; max-height: 100px; margin-bottom: 8px; }
      to { transform: translateX(100%); opacity: 0; max-height: 0; margin-bottom: 0; }
    }

    .feed-item.slide-out {
      animation: slideOut 0.5s ease forwards;
    }

    .feed-item .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid var(--neon-pink);
      box-shadow: 0 0 8px var(--neon-pink);
      flex-shrink: 0;
      object-fit: cover;
      background: var(--ui-border);
    }

    .feed-item .feed-content {
      flex: 1;
      min-width: 0;
    }

    .feed-item .change-header {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 2px;
    }

    .feed-item .change-amount {
      font-weight: 700;
      font-size: 14px;
    }

    .feed-item.speed-up .change-amount { color: var(--fire-orange); }
    .feed-item.slow-down .change-amount { color: var(--ice-blue); }

    .feed-item .change-user {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      color: var(--neon-pink);
      text-shadow: 0 0 6px var(--neon-pink);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .feed-item .change-rate {
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: var(--neon-green);
      text-shadow: 0 0 8px var(--neon-green);
      margin: 3px 0;
    }

    .feed-item.speed-up .change-rate { color: var(--fire-orange); text-shadow: 0 0 8px var(--fire-orange); }
    .feed-item.slow-down .change-rate { color: var(--ice-blue); text-shadow: 0 0 8px var(--ice-blue); }

    .feed-item .change-time {
      font-size: 8px;
      color: #666;
    }

    /* ============ BOTTOM - PLAYRATE BAR ============ */
    .bottom-section {
      grid-column: 1 / -1;
      padding: 5px 10px;
    }

    .playrate-bar-container {
      position: relative;
      height: 25px;
      background: var(--ui-dark);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--ui-border);
    }

    .playrate-bar-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
    }

    .bar-zone {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 8px;
      color: rgba(255,255,255,0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
      border-right: 1px solid var(--ui-border);
    }

    .bar-zone:last-child { border-right: none; }
    .bar-zone.ice { background: rgba(136, 221, 255, 0.1); }
    .bar-zone.normal { background: rgba(0, 255, 136, 0.1); }
    .bar-zone.fire { background: rgba(255, 68, 0, 0.1); }

    .playrate-marker {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 35px;
      background: var(--neon-pink);
      border-radius: 3px;
      box-shadow: 0 0 15px var(--neon-pink);
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 10;
    }

    .bar-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      padding: 0 10px;
      font-size: 9px;
      color: #666;
    }

    /* ============ PARTICLE EFFECTS ============ */
    .particles-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      overflow: hidden;
      contain: strict;
      will-change: contents;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      contain: layout style;
      will-change: transform, opacity;
      backface-visibility: hidden;
      transform: translate3d(0, 0, 0);
    }

    .particle.fire {
      background: radial-gradient(circle, var(--fire-orange) 0%, transparent 70%);
    }

    .particle.ice {
      background: radial-gradient(circle, var(--ice-blue) 0%, transparent 70%);
    }

    @keyframes particleFire {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
      100% { transform: translate3d(0, -150px, 0) scale(0); opacity: 0; }
    }

    @keyframes particleIce {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
      100% { transform: translate3d(0, 150px, 0) scale(0); opacity: 0; }
    }

    /* ============ REALISTIC FIRE - 60FPS GPU ACCELERATED ============ */

    /* Base flame particle - teardrop shape */
    .particle.flame {
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      mix-blend-mode: screen;
      contain: layout style paint;
      filter: none; /* No blur for 60fps */
    }

    /* Core flame - hottest, white-yellow center */
    .particle.flame.core {
      background: radial-gradient(ellipse at 50% 70%,
        rgba(255, 255, 255, 0.95) 0%,
        rgba(255, 255, 200, 0.9) 15%,
        rgba(255, 220, 100, 0.8) 30%,
        rgba(255, 180, 50, 0.6) 50%,
        rgba(255, 120, 0, 0.3) 70%,
        transparent 100%);
    }

    /* Inner flame - orange-yellow */
    .particle.flame.inner {
      background: radial-gradient(ellipse at 50% 65%,
        rgba(255, 200, 80, 0.85) 0%,
        rgba(255, 150, 30, 0.7) 30%,
        rgba(255, 100, 0, 0.5) 55%,
        rgba(200, 50, 0, 0.25) 75%,
        transparent 100%);
    }

    /* Outer flame - red-orange */
    .particle.flame.outer {
      background: radial-gradient(ellipse at 50% 60%,
        rgba(255, 130, 30, 0.7) 0%,
        rgba(255, 80, 0, 0.5) 35%,
        rgba(200, 30, 0, 0.3) 60%,
        rgba(120, 0, 0, 0.1) 80%,
        transparent 100%);
    }

    /* Smoke wisps at top */
    .particle.smoke {
      background: radial-gradient(circle,
        rgba(80, 80, 80, 0.3) 0%,
        rgba(60, 60, 60, 0.15) 40%,
        transparent 70%);
      mix-blend-mode: multiply;
    }

    /* Multiple animation variations for natural look */
    .particle.flame.anim-1 { animation: flameRise1 var(--dur, 1s) ease-out forwards; }
    .particle.flame.anim-2 { animation: flameRise2 var(--dur, 1s) ease-out forwards; }
    .particle.flame.anim-3 { animation: flameRise3 var(--dur, 1s) ease-out forwards; }
    .particle.smoke { animation: smokeRise var(--dur, 1.5s) ease-out forwards; }

    /* Varied flame animations - turbulent motion */
    @keyframes flameRise1 {
      0% { transform: translate3d(0, 0, 0) scale(1, 1) rotate(0deg); opacity: 0.9; }
      20% { transform: translate3d(-8px, -40px, 0) scale(0.95, 1.2) rotate(-5deg); opacity: 1; }
      40% { transform: translate3d(5px, -90px, 0) scale(0.8, 1.0) rotate(3deg); opacity: 0.75; }
      60% { transform: translate3d(-3px, -140px, 0) scale(0.6, 0.7) rotate(-2deg); opacity: 0.45; }
      80% { transform: translate3d(6px, -180px, 0) scale(0.35, 0.4) rotate(4deg); opacity: 0.2; }
      100% { transform: translate3d(0, -220px, 0) scale(0.1, 0.15) rotate(0deg); opacity: 0; }
    }

    @keyframes flameRise2 {
      0% { transform: translate3d(0, 0, 0) scale(1, 1) rotate(0deg); opacity: 0.85; }
      25% { transform: translate3d(10px, -50px, 0) scale(0.9, 1.15) rotate(6deg); opacity: 0.95; }
      50% { transform: translate3d(-6px, -110px, 0) scale(0.7, 0.85) rotate(-4deg); opacity: 0.6; }
      75% { transform: translate3d(4px, -165px, 0) scale(0.4, 0.45) rotate(2deg); opacity: 0.25; }
      100% { transform: translate3d(-2px, -210px, 0) scale(0.15, 0.2) rotate(-1deg); opacity: 0; }
    }

    @keyframes flameRise3 {
      0% { transform: translate3d(0, 0, 0) scale(1, 1) rotate(0deg); opacity: 0.8; }
      15% { transform: translate3d(-5px, -30px, 0) scale(1.05, 1.25) rotate(-3deg); opacity: 0.9; }
      35% { transform: translate3d(8px, -75px, 0) scale(0.85, 0.95) rotate(5deg); opacity: 0.7; }
      55% { transform: translate3d(-4px, -125px, 0) scale(0.55, 0.6) rotate(-3deg); opacity: 0.4; }
      80% { transform: translate3d(3px, -175px, 0) scale(0.3, 0.35) rotate(2deg); opacity: 0.15; }
      100% { transform: translate3d(0, -200px, 0) scale(0.1, 0.1) rotate(0deg); opacity: 0; }
    }

    @keyframes smokeRise {
      0% { transform: translate3d(0, -150px, 0) scale(0.5); opacity: 0; }
      20% { transform: translate3d(5px, -180px, 0) scale(0.8); opacity: 0.2; }
      60% { transform: translate3d(-8px, -250px, 0) scale(1.2); opacity: 0.15; }
      100% { transform: translate3d(10px, -320px, 0) scale(1.8); opacity: 0; }
    }

    /* Canvas fire simulation */
    #fireCanvas {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 150px;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.3s, height 0.5s ease-out;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #fireCanvas.active {
      opacity: 1;
    }

    /* Fire intensity text effects */
    .fire-text-effect {
      transition: text-shadow 0.3s, color 0.3s, transform 0.1s;
    }

    .fire-text-effect.intensity-low {
      text-shadow:
        0 0 10px currentColor,
        0 0 20px rgba(255, 100, 0, 0.3);
    }

    .fire-text-effect.intensity-medium {
      text-shadow:
        0 0 15px currentColor,
        0 0 30px rgba(255, 100, 0, 0.5),
        0 0 50px rgba(255, 50, 0, 0.3);
      animation: fireTextPulse 0.5s ease-in-out infinite alternate;
    }

    .fire-text-effect.intensity-high {
      color: #ffcc00 !important;
      text-shadow:
        0 0 10px #ff8800,
        0 0 20px #ff4400,
        0 0 40px #ff2200,
        0 0 60px #ff0000,
        0 0 80px rgba(255, 0, 0, 0.5);
      animation: fireTextIntense 0.15s ease-in-out infinite alternate;
    }

    .fire-text-effect.intensity-max {
      color: #ffffff !important;
      text-shadow:
        0 0 10px #ffff88,
        0 0 20px #ffcc00,
        0 0 40px #ff8800,
        0 0 60px #ff4400,
        0 0 100px #ff0000,
        0 0 150px rgba(255, 0, 0, 0.8);
      animation: fireTextMax 0.1s ease-in-out infinite alternate;
    }

    @keyframes fireTextPulse {
      0% { transform: scale(1); filter: brightness(1); }
      100% { transform: scale(1.02); filter: brightness(1.1); }
    }

    @keyframes fireTextIntense {
      0% { transform: scale(1) translateY(0); filter: brightness(1.1); }
      100% { transform: scale(1.03) translateY(-1px); filter: brightness(1.3); }
    }

    @keyframes fireTextMax {
      0% { transform: scale(1) translateY(0); filter: brightness(1.2); }
      50% { transform: scale(1.05) translateY(-2px); filter: brightness(1.5); }
      100% { transform: scale(1.02) translateY(-1px); filter: brightness(1.3); }
    }

    /* Fire glow with flickering */
    .fire-glow {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: linear-gradient(to top,
        rgba(255, 100, 0, 0.35) 0%,
        rgba(255, 60, 0, 0.2) 30%,
        rgba(255, 30, 0, 0.08) 60%,
        transparent 100%);
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      will-change: opacity;
      contain: strict;
    }

    .fire-glow.active {
      opacity: 1;
      animation: glowFlicker 0.15s ease-in-out infinite alternate;
    }

    @keyframes glowFlicker {
      0% { opacity: 0.85; }
      100% { opacity: 1; }
    }

    /* ============ ICE/FROST EFFECTS ============ */

    /* Canvas ice simulation */
    #iceCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 150px;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.3s, height 0.5s ease-out;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #iceCanvas.active {
      opacity: 1;
    }

    /* Ice intensity text effects */
    .ice-text-effect {
      transition: text-shadow 0.3s, color 0.3s, transform 0.1s;
    }

    .ice-text-effect.intensity-low {
      text-shadow:
        0 0 10px currentColor,
        0 0 20px rgba(136, 200, 255, 0.3);
    }

    .ice-text-effect.intensity-medium {
      text-shadow:
        0 0 15px currentColor,
        0 0 30px rgba(100, 180, 255, 0.5),
        0 0 50px rgba(50, 150, 255, 0.3);
      animation: iceTextPulse 0.8s ease-in-out infinite alternate;
    }

    .ice-text-effect.intensity-high {
      color: #88ddff !important;
      text-shadow:
        0 0 10px #66ccff,
        0 0 20px #44aaff,
        0 0 40px #2288ff,
        0 0 60px #0066ff,
        0 0 80px rgba(0, 100, 255, 0.5);
      animation: iceTextIntense 0.2s ease-in-out infinite alternate;
    }

    .ice-text-effect.intensity-max {
      color: #ffffff !important;
      text-shadow:
        0 0 10px #eeffff,
        0 0 20px #bbffff,
        0 0 40px #88ddff,
        0 0 60px #44aaff,
        0 0 100px #0088ff,
        0 0 150px rgba(0, 136, 255, 0.8);
      animation: iceTextMax 0.15s ease-in-out infinite alternate;
    }

    @keyframes iceTextPulse {
      0% { transform: scale(1); filter: brightness(1); }
      100% { transform: scale(0.98); filter: brightness(1.1); }
    }

    @keyframes iceTextIntense {
      0% { transform: scale(1) translateY(0); filter: brightness(1.1); }
      100% { transform: scale(0.97) translateY(1px); filter: brightness(1.2); }
    }

    @keyframes iceTextMax {
      0% { transform: scale(1) translateY(0); filter: brightness(1.2); }
      50% { transform: scale(0.96) translateY(1px); filter: brightness(1.4); }
      100% { transform: scale(0.98) translateY(0); filter: brightness(1.3); }
    }

    /* Frozen/shiver effect for text */
    @keyframes iceShiver {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-1px); }
      75% { transform: translateX(1px); }
    }

    .ice-text-effect.intensity-max {
      animation: iceTextMax 0.15s ease-in-out infinite alternate, iceShiver 0.1s linear infinite;
    }

    /* Ice glow from top */
    .ice-glow {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: linear-gradient(to bottom,
        rgba(100, 180, 255, 0.35) 0%,
        rgba(60, 150, 255, 0.2) 30%,
        rgba(30, 120, 255, 0.08) 60%,
        transparent 100%);
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      will-change: opacity;
      contain: strict;
    }

    .ice-glow.active {
      opacity: 1;
      animation: iceGlowPulse 2s ease-in-out infinite alternate;
    }

    @keyframes iceGlowPulse {
      0% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Frost crystal particles */
    .frost-particle {
      position: absolute;
      pointer-events: none;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(136,221,255,0.6) 40%, transparent 70%);
      border-radius: 50%;
      animation: frostFall linear forwards;
    }

    @keyframes frostFall {
      0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
      100% { transform: translateY(200px) rotate(180deg) scale(0.3); opacity: 0; }
    }

    /* Ice crack overlay effect */
    .ice-crack-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      opacity: 0;
      background:
        radial-gradient(ellipse at 20% 10%, rgba(255,255,255,0.1) 0%, transparent 30%),
        radial-gradient(ellipse at 80% 15%, rgba(200,230,255,0.1) 0%, transparent 25%),
        radial-gradient(ellipse at 50% 5%, rgba(180,220,255,0.15) 0%, transparent 35%);
      transition: opacity 0.5s;
    }

    .ice-crack-overlay.active {
      opacity: 1;
    }

    /* Heat shimmer effect above fire */
    .heat-shimmer {
      position: fixed;
      bottom: 80px;
      left: 0;
      right: 0;
      height: 200px;
      background: transparent;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      will-change: opacity;
    }

    .heat-shimmer.active {
      opacity: 1;
      animation: shimmer 0.1s linear infinite;
    }

    @keyframes shimmer {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(1px); }
    }

    /* Ember sparks */
    .particle.ember {
      border-radius: 50%;
      background: #ffdd44;
      box-shadow: 0 0 3px #ff8800, 0 0 6px #ff4400;
    }

    @keyframes emberFloat {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
      30% { transform: translate3d(15px, -80px, 0) scale(0.9); opacity: 0.9; }
      60% { transform: translate3d(-10px, -180px, 0) scale(0.6); opacity: 0.6; }
      100% { transform: translate3d(20px, -280px, 0) scale(0.2); opacity: 0; }
    }

    /* Auto-reset countdown overlay */
    .countdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 300;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .countdown-overlay.active {
      opacity: 1;
    }

    .countdown-label {
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      color: var(--neon-yellow);
      text-shadow: 0 0 20px var(--neon-yellow);
      letter-spacing: 4px;
      margin-bottom: 20px;
      animation: countdownPulse 1s ease-in-out infinite;
    }

    .countdown-number {
      font-family: 'Orbitron', sans-serif;
      font-size: 120px;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow:
        0 0 20px var(--neon-green),
        0 0 40px var(--neon-green),
        0 0 80px var(--neon-green);
      line-height: 1;
      animation: countdownBounce 1s ease-in-out infinite;
    }

    .countdown-number.urgent {
      color: var(--neon-red);
      text-shadow:
        0 0 20px var(--neon-red),
        0 0 40px var(--neon-red),
        0 0 80px var(--neon-red);
      animation: countdownUrgent 0.5s ease-in-out infinite;
    }

    @keyframes countdownPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    @keyframes countdownBounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes countdownUrgent {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    .countdown-bar {
      width: 300px;
      height: 8px;
      background: var(--ui-dark);
      border-radius: 4px;
      margin-top: 30px;
      overflow: hidden;
      border: 2px solid var(--neon-green);
      box-shadow: 0 0 15px var(--neon-green);
    }

    .countdown-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-green), var(--neon-yellow));
      transition: width 1s linear;
      box-shadow: 0 0 10px var(--neon-green);
    }

    .countdown-bar.urgent {
      border-color: var(--neon-red);
      box-shadow: 0 0 15px var(--neon-red);
    }

    .countdown-bar.urgent .countdown-bar-fill {
      background: linear-gradient(90deg, var(--neon-red), var(--neon-yellow));
    }

    /* ============ THRESHOLD EFFECTS ============ */
    .effect-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .effect-overlay.fire-effect {
      background: radial-gradient(ellipse at bottom, rgba(255,68,0,0.3) 0%, transparent 70%);
      border-bottom: 5px solid var(--fire-orange);
      box-shadow: inset 0 -100px 100px -50px rgba(255,68,0,0.4);
    }

    .effect-overlay.ice-effect {
      background: radial-gradient(ellipse at top, rgba(136,221,255,0.3) 0%, transparent 70%);
      border-top: 5px solid var(--ice-blue);
      box-shadow: inset 0 100px 100px -50px rgba(136,221,255,0.4);
    }

    .effect-overlay.active { opacity: 1; }

    /* Flash effect */
    .flash-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 150;
      background: white;
      opacity: 0;
    }

    .flash-overlay.flash {
      animation: flashAnim 0.2s ease-out;
    }

    @keyframes flashAnim {
      0% { opacity: 0.5; }
      100% { opacity: 0; }
    }

    /* URL output */
    .url-output {
      margin-top: 20px;
      padding: 15px;
      background: var(--bg-color);
      border: 1px solid var(--ui-border);
      border-radius: 8px;
    }

    .url-output input {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid var(--ui-border);
      border-radius: 4px;
      background: var(--ui-dark);
      color: var(--neon-green);
      font-family: monospace;
      font-size: 10px;
    }

    .url-output button {
      width: 100%;
      padding: 10px;
      border: 2px solid var(--neon-blue);
      border-radius: 5px;
      background: transparent;
      color: var(--neon-blue);
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      cursor: pointer;
    }
    .url-output button:hover { background: var(--neon-blue); color: var(--bg-color); }

    .copied-msg {
      text-align: center;
      color: var(--neon-green);
      font-size: 10px;
      margin-top: 8px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .copied-msg.show { opacity: 1; }
  </style>
</head>
<body>
  <button class="settings-toggle" id="settingsToggle">CONFIG</button>

  <div class="settings-panel" id="settingsPanel">
    <h2>GAME HUD CONFIG</h2>

    <h3>Display</h3>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setTransparent">
        Transparent Background
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setScanlines" checked>
        Scanlines Effect
      </label>
    </div>

    <h3>Elements</h3>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowBpm" checked>
        Show BPM
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowTempo" checked>
        Show Calculated Tempo
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowTimeSig" checked>
        Show Time Signature
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowGauge" checked>
        Show Speedometer
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowBar" checked>
        Show Playrate Bar
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowBeat" checked>
        Show Beat Indicator
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowFeed" checked>
        Show Change Feed
      </label>
    </div>

    <h3>Effects</h3>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setScreenShake" checked>
        Screen Shake
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setFlash" checked>
        Flash on Change
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setParticles" checked>
        Particle Effects
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setThresholdEffects" checked>
        Fire/Ice Threshold Effects
      </label>
    </div>

    <h3>Thresholds</h3>
    <div class="settings-group">
      <label>Fire Zone (above): <span id="fireThresholdVal">1.3</span>x</label>
      <input type="range" id="setFireThreshold" min="1.1" max="1.8" step="0.1" value="1.3">
    </div>
    <div class="settings-group">
      <label>Ice Zone (below): <span id="iceThresholdVal">0.8</span>x</label>
      <input type="range" id="setIceThreshold" min="0.5" max="0.9" step="0.1" value="0.8">
    </div>

    <div class="btn-row">
      <button class="btn-save" id="saveSettings">SAVE</button>
      <button class="btn-reset" id="resetSettings">RESET</button>
    </div>

    <div class="url-output">
      <label style="color: #666; font-size: 10px;">OBS URL:</label>
      <input type="text" id="generatedUrl" readonly>
      <button id="copyUrl">COPY URL</button>
      <div class="copied-msg" id="copiedMsg">COPIED!</div>
    </div>
  </div>

  <div class="hud-container" id="hudContainer">
    <!-- Top Section: BPM, Calculated Tempo & Time Sig -->
    <div class="top-section">
      <div class="bpm-display" id="bpmSection">
        <div class="bpm-label">BPM</div>
        <div class="bpm-value" id="bpmValue">120</div>
      </div>
      <div class="tempo-display" id="tempoSection">
        <div class="tempo-label">TEMPO</div>
        <div class="tempo-value" id="tempoValue">120</div>
      </div>
      <div class="time-sig-display" id="timeSigSection">
        <span id="timeSigValue">4/4</span>
      </div>
    </div>

    <!-- Left: Beat Indicator -->
    <div class="left-section" id="beatSection">
      <div class="beat-ring-container">
        <div class="beat-ring" id="beatRing">
          <div class="beat-number" id="beatNumber">1</div>
        </div>
      </div>
      <div class="beat-dots" id="beatDots"></div>
    </div>

    <!-- Center: Playrate Gauge -->
    <div class="center-section" id="gaugeSection">
      <div class="speed-indicator slow" id="slowIndicator">SLOW</div>
      <div class="speed-indicator fast" id="fastIndicator">FAST!</div>

      <div class="gauge-container">
        <svg class="gauge-svg" viewBox="0 0 350 220">
          <!-- Background arc -->
          <path class="gauge-bg" d="M 30 180 A 145 145 0 0 1 320 180" />

          <!-- Colored fill arc -->
          <path class="gauge-fill" id="gaugeFill" d="M 30 180 A 145 145 0 0 1 320 180"
                stroke="var(--neon-green)"
                stroke-dasharray="455"
                stroke-dashoffset="227" />

          <!-- Tick marks and labels -->
          <g class="gauge-ticks">
            <text x="25" y="200" text-anchor="middle">0.5x</text>
            <text x="95" y="85" text-anchor="middle">0.75x</text>
            <text x="175" y="55" text-anchor="middle">1.0x</text>
            <text x="255" y="85" text-anchor="middle">1.5x</text>
            <text x="325" y="200" text-anchor="middle">2.0x</text>
          </g>

          <!-- Needle -->
          <polygon class="gauge-needle" id="gaugeNeedle" points="175,60 170,180 180,180" />

          <!-- Center dot -->
          <circle class="gauge-center-dot" cx="175" cy="180" r="15" />
        </svg>
      </div>

      <div class="playrate-display">
        <div class="playrate-value" id="playrateValue">1.00x</div>
        <div class="playrate-label">PLAYRATE</div>
      </div>
    </div>

    <!-- Right: Change Feed -->
    <div class="right-section" id="feedSection">
      <div class="feed-title">CHANGES</div>
      <div class="change-feed" id="changeFeed"></div>
    </div>

    <!-- Bottom: Playrate Bar -->
    <div class="bottom-section" id="barSection">
      <div class="playrate-bar-container">
        <div class="playrate-bar-bg">
          <div class="bar-zone ice">SLOW</div>
          <div class="bar-zone normal">NORMAL</div>
          <div class="bar-zone fire">FAST</div>
        </div>
        <div class="playrate-marker" id="playrateMarker"></div>
      </div>
      <div class="bar-labels">
        <span>0.5x</span>
        <span>1.0x</span>
        <span>2.0x</span>
      </div>
    </div>
  </div>

  <!-- Effect overlays -->
  <div class="effect-overlay fire-effect" id="fireOverlay"></div>
  <div class="effect-overlay ice-effect" id="iceOverlay"></div>
  <div class="flash-overlay" id="flashOverlay"></div>
  <canvas id="fireCanvas"></canvas>
  <canvas id="iceCanvas"></canvas>
  <div class="ice-glow" id="iceGlow"></div>
  <div class="ice-crack-overlay" id="iceCrackOverlay"></div>
  <div class="particles-container" id="particlesContainer"></div>

  <!-- Audio elements for sound effects -->
  <audio id="iceCrackSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
  </audio>

  <!-- Auto-reset countdown -->
  <div class="countdown-overlay" id="countdownOverlay">
    <div class="countdown-label">RESETTING IN</div>
    <div class="countdown-number" id="countdownNumber">10</div>
    <div class="countdown-bar" id="countdownBar">
      <div class="countdown-bar-fill" id="countdownBarFill"></div>
    </div>
  </div>

  <script src="main.js"></script>
  <script>
    const STORAGE_KEY = 'hyd_gamehud_settings';

    // Default avatar SVG (properly encoded for use in src attribute)
    const DEFAULT_AVATAR = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="#333"/><circle cx="50" cy="40" r="20" fill="#666"/><ellipse cx="50" cy="85" rx="35" ry="25" fill="#666"/></svg>');

    // Handle avatar loading errors
    function handleAvatarError(img) {
      img.onerror = null; // Prevent infinite loop
      img.src = DEFAULT_AVATAR;
    }

    const defaults = {
      transparent: false,
      scanlines: true,
      showBpm: true,
      showTempo: true,
      showTimeSig: true,
      showGauge: true,
      showBar: true,
      showBeat: true,
      showFeed: true,
      screenShake: true,
      flash: true,
      particles: true,
      thresholdEffects: true,
      fireThreshold: 1.3,
      iceThreshold: 0.8,
      botUrl: 'ws://localhost:9030'
    };

    function loadSettings() {
      const urlParams = new URLSearchParams(window.location.search);
      const stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');

      return {
        transparent: urlParams.has('transparent') ? urlParams.get('transparent') === 'true' : (stored.transparent ?? defaults.transparent),
        scanlines: urlParams.has('scanlines') ? urlParams.get('scanlines') !== 'false' : (stored.scanlines ?? defaults.scanlines),
        showBpm: urlParams.has('bpm') ? urlParams.get('bpm') !== 'false' : (stored.showBpm ?? defaults.showBpm),
        showTempo: urlParams.has('tempo') ? urlParams.get('tempo') !== 'false' : (stored.showTempo ?? defaults.showTempo),
        showTimeSig: urlParams.has('timesig') ? urlParams.get('timesig') !== 'false' : (stored.showTimeSig ?? defaults.showTimeSig),
        showGauge: urlParams.has('gauge') ? urlParams.get('gauge') !== 'false' : (stored.showGauge ?? defaults.showGauge),
        showBar: urlParams.has('bar') ? urlParams.get('bar') !== 'false' : (stored.showBar ?? defaults.showBar),
        showBeat: urlParams.has('beat') ? urlParams.get('beat') !== 'false' : (stored.showBeat ?? defaults.showBeat),
        showFeed: urlParams.has('feed') ? urlParams.get('feed') !== 'false' : (stored.showFeed ?? defaults.showFeed),
        screenShake: urlParams.has('shake') ? urlParams.get('shake') !== 'false' : (stored.screenShake ?? defaults.screenShake),
        flash: urlParams.has('flash') ? urlParams.get('flash') !== 'false' : (stored.flash ?? defaults.flash),
        particles: urlParams.has('particles') ? urlParams.get('particles') !== 'false' : (stored.particles ?? defaults.particles),
        thresholdEffects: urlParams.has('threshold') ? urlParams.get('threshold') !== 'false' : (stored.thresholdEffects ?? defaults.thresholdEffects),
        fireThreshold: parseFloat(urlParams.get('fire')) || stored.fireThreshold || defaults.fireThreshold,
        iceThreshold: parseFloat(urlParams.get('ice')) || stored.iceThreshold || defaults.iceThreshold,
        botUrl: urlParams.get('bot') || stored.botUrl || defaults.botUrl,
        hideSettings: urlParams.get('hideSettings') === 'true'
      };
    }

    let settings = loadSettings();

    // Elements
    const hudContainer = document.getElementById('hudContainer');
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsToggle = document.getElementById('settingsToggle');
    const bpmSection = document.getElementById('bpmSection');
    const tempoSection = document.getElementById('tempoSection');
    const tempoValue = document.getElementById('tempoValue');
    const timeSigSection = document.getElementById('timeSigSection');
    const gaugeSection = document.getElementById('gaugeSection');
    const barSection = document.getElementById('barSection');
    const beatSection = document.getElementById('beatSection');
    const feedSection = document.getElementById('feedSection');
    const bpmValue = document.getElementById('bpmValue');
    const timeSigValue = document.getElementById('timeSigValue');
    const playrateValue = document.getElementById('playrateValue');
    const gaugeFill = document.getElementById('gaugeFill');
    const gaugeNeedle = document.getElementById('gaugeNeedle');
    const playrateMarker = document.getElementById('playrateMarker');
    const beatRing = document.getElementById('beatRing');
    const beatNumber = document.getElementById('beatNumber');
    const beatDots = document.getElementById('beatDots');
    const changeFeed = document.getElementById('changeFeed');
    const fireOverlay = document.getElementById('fireOverlay');
    const iceOverlay = document.getElementById('iceOverlay');
    const flashOverlay = document.getElementById('flashOverlay');
    const particlesContainer = document.getElementById('particlesContainer');
    const slowIndicator = document.getElementById('slowIndicator');
    const fastIndicator = document.getElementById('fastIndicator');

    // Inputs
    const inputs = {
      transparent: document.getElementById('setTransparent'),
      scanlines: document.getElementById('setScanlines'),
      showBpm: document.getElementById('setShowBpm'),
      showTempo: document.getElementById('setShowTempo'),
      showTimeSig: document.getElementById('setShowTimeSig'),
      showGauge: document.getElementById('setShowGauge'),
      showBar: document.getElementById('setShowBar'),
      showBeat: document.getElementById('setShowBeat'),
      showFeed: document.getElementById('setShowFeed'),
      screenShake: document.getElementById('setScreenShake'),
      flash: document.getElementById('setFlash'),
      particles: document.getElementById('setParticles'),
      thresholdEffects: document.getElementById('setThresholdEffects'),
      fireThreshold: document.getElementById('setFireThreshold'),
      iceThreshold: document.getElementById('setIceThreshold')
    };

    function applySettings() {
      document.body.classList.toggle('transparent-bg', settings.transparent);
      document.body.classList.toggle('no-scanlines', !settings.scanlines);

      bpmSection.style.display = settings.showBpm ? '' : 'none';
      tempoSection.style.display = settings.showTempo ? '' : 'none';
      timeSigSection.style.display = settings.showTimeSig ? '' : 'none';
      gaugeSection.style.display = settings.showGauge ? '' : 'none';
      barSection.style.display = settings.showBar ? '' : 'none';
      beatSection.style.display = settings.showBeat ? '' : 'none';
      feedSection.style.display = settings.showFeed ? '' : 'none';

      if (settings.hideSettings) {
        settingsToggle.classList.add('hidden');
        settingsPanel.classList.add('hidden');
      }

      // Update inputs
      inputs.transparent.checked = settings.transparent;
      inputs.scanlines.checked = settings.scanlines;
      inputs.showBpm.checked = settings.showBpm;
      inputs.showTempo.checked = settings.showTempo;
      inputs.showTimeSig.checked = settings.showTimeSig;
      inputs.showGauge.checked = settings.showGauge;
      inputs.showBar.checked = settings.showBar;
      inputs.showBeat.checked = settings.showBeat;
      inputs.showFeed.checked = settings.showFeed;
      inputs.screenShake.checked = settings.screenShake;
      inputs.flash.checked = settings.flash;
      inputs.particles.checked = settings.particles;
      inputs.thresholdEffects.checked = settings.thresholdEffects;
      inputs.fireThreshold.value = settings.fireThreshold;
      inputs.iceThreshold.value = settings.iceThreshold;

      document.getElementById('fireThresholdVal').textContent = settings.fireThreshold;
      document.getElementById('iceThresholdVal').textContent = settings.iceThreshold;
    }

    function readSettings() {
      settings.transparent = inputs.transparent.checked;
      settings.scanlines = inputs.scanlines.checked;
      settings.showBpm = inputs.showBpm.checked;
      settings.showTempo = inputs.showTempo.checked;
      settings.showTimeSig = inputs.showTimeSig.checked;
      settings.showGauge = inputs.showGauge.checked;
      settings.showBar = inputs.showBar.checked;
      settings.showBeat = inputs.showBeat.checked;
      settings.showFeed = inputs.showFeed.checked;
      settings.screenShake = inputs.screenShake.checked;
      settings.flash = inputs.flash.checked;
      settings.particles = inputs.particles.checked;
      settings.thresholdEffects = inputs.thresholdEffects.checked;
      settings.fireThreshold = parseFloat(inputs.fireThreshold.value);
      settings.iceThreshold = parseFloat(inputs.iceThreshold.value);
    }

    function generateUrl() {
      const base = window.location.origin + window.location.pathname;
      const p = new URLSearchParams();
      p.set('transparent', settings.transparent);
      p.set('scanlines', settings.scanlines);
      p.set('bpm', settings.showBpm);
      p.set('tempo', settings.showTempo);
      p.set('timesig', settings.showTimeSig);
      p.set('gauge', settings.showGauge);
      p.set('bar', settings.showBar);
      p.set('beat', settings.showBeat);
      p.set('feed', settings.showFeed);
      p.set('shake', settings.screenShake);
      p.set('flash', settings.flash);
      p.set('particles', settings.particles);
      p.set('threshold', settings.thresholdEffects);
      p.set('fire', settings.fireThreshold);
      p.set('ice', settings.iceThreshold);
      p.set('hideSettings', 'true');
      document.getElementById('generatedUrl').value = base + '?' + p.toString();
    }

    // Event listeners
    Object.values(inputs).forEach(input => {
      input.addEventListener('change', () => { readSettings(); applySettings(); generateUrl(); });
      input.addEventListener('input', () => { readSettings(); applySettings(); generateUrl(); });
    });

    settingsToggle.addEventListener('click', () => settingsPanel.classList.toggle('open'));

    document.getElementById('saveSettings').addEventListener('click', () => {
      readSettings();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      alert('Settings saved!');
    });

    document.getElementById('resetSettings').addEventListener('click', () => {
      if (confirm('Reset all settings?')) {
        localStorage.removeItem(STORAGE_KEY);
        settings = { ...defaults };
        applySettings();
        generateUrl();
      }
    });

    document.getElementById('copyUrl').addEventListener('click', () => {
      const url = document.getElementById('generatedUrl');
      url.select();
      navigator.clipboard.writeText(url.value).then(() => {
        const msg = document.getElementById('copiedMsg');
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), 2000);
      });
    });

    applySettings();
    generateUrl();

    // ============ GAME STATE ============
    let currentPlayrate = 1.0;
    let lastPlayrate = 1.0;
    let currentBpm = 120;
    let currentTimeSig = '4/4';
    let currentBeat = 1;
    let timeSigNum = 4;
    let changeHistory = [];

    // Generate beat dots
    function generateBeatDots(beats) {
      beatDots.innerHTML = '';
      for (let i = 1; i <= beats; i++) {
        const dot = document.createElement('div');
        dot.className = 'beat-dot' + (i === 1 ? ' downbeat-dot' : '');
        dot.id = 'dot-' + i;
        beatDots.appendChild(dot);
      }
    }
    generateBeatDots(4);

    // ============ EFFECTS ============
    function triggerShake() {
      if (!settings.screenShake) return;
      hudContainer.classList.remove('shake');
      void hudContainer.offsetWidth; // Reflow
      hudContainer.classList.add('shake');
    }

    function triggerFlash() {
      if (!settings.flash) return;
      flashOverlay.classList.remove('flash');
      void flashOverlay.offsetWidth;
      flashOverlay.classList.add('flash');
    }

    // Burst particle pool
    const burstPool = [];
    const BURST_POOL_SIZE = 40;
    for (let i = 0; i < BURST_POOL_SIZE; i++) {
      const p = document.createElement('div');
      p.className = 'particle';
      p.style.display = 'none';
      particlesContainer.appendChild(p);
      burstPool.push(p);
    }

    function spawnParticles(type, count = 15) {
      if (!settings.particles) return;

      // Use DocumentFragment for batch insert if pool exhausted
      const isFireType = type === 'fire';

      for (let i = 0; i < count; i++) {
        const p = burstPool.find(p => p.style.display === 'none');
        if (!p) continue;

        const size = 10 + Math.random() * 20;
        const dur = 0.4 + Math.random() * 0.4;

        p.className = 'particle ' + type;
        p.style.cssText = `
          display:block;
          width:${size}px;
          height:${size}px;
          left:${Math.random() * 100}%;
          ${isFireType ? 'bottom:0' : 'top:0'};
          animation:particle${isFireType ? 'Fire' : 'Ice'} ${dur}s ease-out forwards;
          animation-delay:${Math.random() * 0.3}s;
        `;

        setTimeout(() => { p.style.display = 'none'; }, (dur + 0.3) * 1000);
      }
    }

    function updateThresholdEffects(playrate) {
      if (!settings.thresholdEffects) {
        fireOverlay.classList.remove('active');
        iceOverlay.classList.remove('active');
        return;
      }

      if (playrate >= settings.fireThreshold) {
        fireOverlay.classList.add('active');
        iceOverlay.classList.remove('active');
        fastIndicator.classList.add('active');
        slowIndicator.classList.remove('active');
      } else if (playrate <= settings.iceThreshold) {
        iceOverlay.classList.add('active');
        fireOverlay.classList.remove('active');
        slowIndicator.classList.add('active');
        fastIndicator.classList.remove('active');
      } else {
        fireOverlay.classList.remove('active');
        iceOverlay.classList.remove('active');
        fastIndicator.classList.remove('active');
        slowIndicator.classList.remove('active');
      }
    }

    // ============ DOOM FIRE SIMULATION (60FPS Canvas) ============
    const fireCanvas = document.getElementById('fireCanvas');
    const fireCtx = fireCanvas.getContext('2d');

    // Fire simulation config
    const FIRE_WIDTH = 160;  // Low res for performance + retro look
    const FIRE_HEIGHT = 50;
    const PIXEL_SIZE = 4;

    // Fire color palette (black -> red -> orange -> yellow -> white)
    const FIRE_PALETTE = [
      [0, 0, 0, 0],         // 0: transparent
      [7, 7, 7, 255],       // 1: near black
      [31, 7, 7, 255],      // 2: dark red
      [47, 15, 7, 255],     // 3
      [71, 15, 7, 255],     // 4
      [87, 23, 7, 255],     // 5
      [103, 31, 7, 255],    // 6
      [119, 31, 7, 255],    // 7
      [143, 39, 7, 255],    // 8
      [159, 47, 7, 255],    // 9
      [175, 63, 7, 255],    // 10
      [191, 71, 7, 255],    // 11
      [199, 71, 7, 255],    // 12
      [223, 79, 7, 255],    // 13
      [223, 87, 7, 255],    // 14
      [223, 87, 7, 255],    // 15
      [215, 95, 7, 255],    // 16
      [215, 95, 7, 255],    // 17
      [215, 103, 15, 255],  // 18
      [207, 111, 15, 255],  // 19
      [207, 119, 15, 255],  // 20
      [207, 127, 15, 255],  // 21
      [207, 135, 23, 255],  // 22
      [199, 135, 23, 255],  // 23
      [199, 143, 23, 255],  // 24
      [199, 151, 31, 255],  // 25
      [191, 159, 31, 255],  // 26
      [191, 159, 31, 255],  // 27
      [191, 167, 39, 255],  // 28
      [191, 167, 39, 255],  // 29
      [191, 175, 47, 255],  // 30
      [183, 175, 47, 255],  // 31
      [183, 183, 47, 255],  // 32
      [183, 183, 55, 255],  // 33
      [207, 207, 111, 255], // 34
      [223, 223, 159, 255], // 35
      [239, 239, 199, 255], // 36
      [255, 255, 255, 255]  // 37: white (hottest)
    ];

    // Fire state
    let firePixels = new Uint8Array(FIRE_WIDTH * FIRE_HEIGHT);
    let fireImageData = null;
    let fireRAF = null;
    let fireIntensity = 0;
    let fireRunning = false;

    // Initialize canvas
    function initFireCanvas() {
      fireCanvas.width = FIRE_WIDTH;
      fireCanvas.height = FIRE_HEIGHT;
      fireImageData = fireCtx.createImageData(FIRE_WIDTH, FIRE_HEIGHT);

      // Initialize bottom row with max heat
      for (let x = 0; x < FIRE_WIDTH; x++) {
        firePixels[(FIRE_HEIGHT - 1) * FIRE_WIDTH + x] = FIRE_PALETTE.length - 1;
      }
    }
    initFireCanvas();

    // Elements to apply fire text effects to
    const fireTextElements = [
      playrateValue,
      tempoValue,
      document.querySelector('.bpm-value'),
      document.querySelector('.beat-number')
    ].filter(Boolean);

    function updateFireTextEffects(intensity) {
      const intensityClass =
        intensity >= 0.85 ? 'intensity-max' :
        intensity >= 0.6 ? 'intensity-high' :
        intensity >= 0.3 ? 'intensity-medium' :
        intensity > 0 ? 'intensity-low' : '';

      fireTextElements.forEach(el => {
        // Remove ice classes first
        el.classList.remove('ice-text-effect', 'intensity-low', 'intensity-medium', 'intensity-high', 'intensity-max');

        if (intensityClass) {
          el.classList.add('fire-text-effect', intensityClass);
        } else {
          el.classList.remove('fire-text-effect');
        }
      });
    }

    function startAmbientFire(intensity) {
      fireIntensity = intensity;
      fireCanvas.classList.add('active');

      // Scale canvas height based on intensity (150px to 400px)
      const minHeight = 150;
      const maxHeight = 400;
      const height = minHeight + intensity * (maxHeight - minHeight);
      fireCanvas.style.height = height + 'px';

      // Apply text effects
      updateFireTextEffects(intensity);

      if (!fireRunning && settings.particles) {
        fireRunning = true;
        fireRAF = requestAnimationFrame(fireLoop);
      }
    }

    function stopAmbientFire() {
      fireIntensity = 0;
      fireCanvas.classList.remove('active');
      fireRunning = false;
      if (fireRAF) {
        cancelAnimationFrame(fireRAF);
        fireRAF = null;
      }
      // Cool down the fire
      firePixels.fill(0);
    }

    function fireLoop() {
      if (!fireRunning) return;

      updateFire();
      renderFire();

      fireRAF = requestAnimationFrame(fireLoop);
    }

    function updateFire() {
      const maxColor = FIRE_PALETTE.length - 1;

      // Intensity affects fuel amount, decay rate, and spread
      // At low intensity (0.1): less fuel, more decay = small flames
      // At high intensity (1.0): max fuel, less decay = towering inferno
      const fuelBase = 0.3 + fireIntensity * 0.7;  // 0.3 to 1.0
      const fuel = Math.floor(maxColor * fuelBase);
      const decayRate = 3.5 - fireIntensity * 2.0;  // 3.5 to 1.5 (less decay at high intensity)
      const spreadChance = 0.3 + fireIntensity * 0.4;  // 0.3 to 0.7

      // Update bottom row (fuel source) with randomness
      for (let x = 0; x < FIRE_WIDTH; x++) {
        // More consistent fuel at higher intensity
        const fuelVariation = 1 - fireIntensity * 0.5;  // Less variation at high intensity
        firePixels[(FIRE_HEIGHT - 1) * FIRE_WIDTH + x] =
          Math.floor(Math.random() * fuel * fuelVariation) + Math.floor(fuel * (1 - fuelVariation));
      }

      // Propagate fire upward
      for (let y = 0; y < FIRE_HEIGHT - 1; y++) {
        for (let x = 0; x < FIRE_WIDTH; x++) {
          const srcIdx = (y + 1) * FIRE_WIDTH + x;
          const pixel = firePixels[srcIdx];

          if (pixel === 0) {
            firePixels[y * FIRE_WIDTH + x] = 0;
          } else {
            // Decay scales with intensity - less decay = taller flames
            const decay = Math.floor(Math.random() * decayRate);

            // Horizontal drift - more spread at higher intensity
            const driftRange = Math.random() < spreadChance ? 2 : 1;
            const drift = Math.floor(Math.random() * (driftRange * 2 + 1)) - driftRange;
            const dstX = Math.min(FIRE_WIDTH - 1, Math.max(0, x + drift));
            const dstIdx = y * FIRE_WIDTH + dstX;

            firePixels[dstIdx] = Math.max(0, pixel - decay);
          }
        }
      }
    }

    function renderFire() {
      const data = fireImageData.data;

      for (let y = 0; y < FIRE_HEIGHT; y++) {
        for (let x = 0; x < FIRE_WIDTH; x++) {
          const fireIdx = y * FIRE_WIDTH + x;
          const colorIdx = firePixels[fireIdx];
          const color = FIRE_PALETTE[colorIdx] || FIRE_PALETTE[0];

          const pixelIdx = fireIdx * 4;
          data[pixelIdx] = color[0];
          data[pixelIdx + 1] = color[1];
          data[pixelIdx + 2] = color[2];
          data[pixelIdx + 3] = color[3];
        }
      }

      fireCtx.putImageData(fireImageData, 0, 0);
    }

    // ============ ICE/FROST SIMULATION (60FPS Canvas) ============
    const iceCanvas = document.getElementById('iceCanvas');
    const iceCtx = iceCanvas.getContext('2d');
    const iceGlow = document.getElementById('iceGlow');
    const iceCrackOverlay = document.getElementById('iceCrackOverlay');
    const iceCrackSound = document.getElementById('iceCrackSound');

    // Ice simulation config
    const ICE_WIDTH = 160;
    const ICE_HEIGHT = 50;

    // Ice color palette (transparent -> dark blue -> cyan -> white)
    const ICE_PALETTE = [
      [0, 0, 0, 0],           // 0: transparent
      [10, 20, 40, 255],      // 1: very dark blue
      [20, 40, 70, 255],      // 2: dark blue
      [30, 60, 100, 255],     // 3
      [40, 80, 130, 255],     // 4
      [50, 100, 160, 255],    // 5
      [60, 120, 180, 255],    // 6
      [70, 140, 200, 255],    // 7
      [80, 155, 210, 255],    // 8
      [90, 170, 220, 255],    // 9
      [100, 180, 230, 255],   // 10
      [110, 190, 235, 255],   // 11
      [120, 200, 240, 255],   // 12: cyan
      [130, 210, 245, 255],   // 13
      [140, 215, 248, 255],   // 14
      [150, 220, 250, 255],   // 15
      [160, 225, 252, 255],   // 16
      [170, 230, 253, 255],   // 17
      [180, 235, 254, 255],   // 18
      [190, 240, 255, 255],   // 19: light cyan
      [200, 242, 255, 255],   // 20
      [210, 244, 255, 255],   // 21
      [220, 246, 255, 255],   // 22
      [230, 248, 255, 255],   // 23
      [235, 250, 255, 255],   // 24
      [240, 252, 255, 255],   // 25
      [245, 253, 255, 255],   // 26
      [250, 254, 255, 255],   // 27
      [255, 255, 255, 255]    // 28: white (coldest/brightest)
    ];

    // Ice state
    let icePixels = new Uint8Array(ICE_WIDTH * ICE_HEIGHT);
    let iceImageData = null;
    let iceRAF = null;
    let iceIntensity = 0;
    let iceRunning = false;
    let lastIceCrackTime = 0;

    // Initialize ice canvas
    function initIceCanvas() {
      iceCanvas.width = ICE_WIDTH;
      iceCanvas.height = ICE_HEIGHT;
      iceImageData = iceCtx.createImageData(ICE_WIDTH, ICE_HEIGHT);
    }
    initIceCanvas();

    // Ice text effects - similar structure to fire but for cold
    function updateIceTextEffects(intensity) {
      const intensityClass =
        intensity >= 0.85 ? 'intensity-max' :
        intensity >= 0.6 ? 'intensity-high' :
        intensity >= 0.3 ? 'intensity-medium' :
        intensity > 0 ? 'intensity-low' : '';

      fireTextElements.forEach(el => {
        // Remove fire classes first
        el.classList.remove('fire-text-effect', 'intensity-low', 'intensity-medium', 'intensity-high', 'intensity-max');

        if (intensityClass) {
          el.classList.add('ice-text-effect', intensityClass);
        } else {
          el.classList.remove('ice-text-effect');
        }
      });
    }

    function clearTextEffects() {
      fireTextElements.forEach(el => {
        el.classList.remove('fire-text-effect', 'ice-text-effect', 'intensity-low', 'intensity-medium', 'intensity-high', 'intensity-max');
      });
    }

    // Play ice crack sound
    function playIceCrackSound() {
      const now = Date.now();
      // Limit sound frequency
      if (now - lastIceCrackTime < 2000) return;
      lastIceCrackTime = now;

      // Try to play sound if it has a valid source
      if (iceCrackSound && iceCrackSound.src && !iceCrackSound.src.includes('AAAA')) {
        iceCrackSound.currentTime = 0;
        iceCrackSound.volume = 0.3 * iceIntensity;
        iceCrackSound.play().catch(() => {}); // Ignore autoplay errors
      }
    }

    function startAmbientIce(intensity) {
      iceIntensity = intensity;
      iceCanvas.classList.add('active');
      iceGlow.classList.add('active');

      // Scale canvas height based on intensity (150px to 350px)
      const minHeight = 150;
      const maxHeight = 350;
      const height = minHeight + intensity * (maxHeight - minHeight);
      iceCanvas.style.height = height + 'px';

      // Show crack overlay at high intensity
      if (intensity >= 0.6) {
        iceCrackOverlay.classList.add('active');
      } else {
        iceCrackOverlay.classList.remove('active');
      }

      // Apply ice text effects
      updateIceTextEffects(intensity);

      // Occasional crack sound at high intensity
      if (intensity >= 0.7 && Math.random() < 0.01) {
        playIceCrackSound();
      }

      if (!iceRunning && settings.particles) {
        iceRunning = true;
        iceRAF = requestAnimationFrame(iceLoop);
      }
    }

    function stopAmbientIce() {
      iceIntensity = 0;
      iceCanvas.classList.remove('active');
      iceGlow.classList.remove('active');
      iceCrackOverlay.classList.remove('active');
      iceRunning = false;
      if (iceRAF) {
        cancelAnimationFrame(iceRAF);
        iceRAF = null;
      }
      // Clear the ice
      icePixels.fill(0);

      // Clear text effects
      clearTextEffects();
    }

    function iceLoop() {
      if (!iceRunning) return;

      updateIce();
      renderIce();

      iceRAF = requestAnimationFrame(iceLoop);
    }

    function updateIce() {
      const maxColor = ICE_PALETTE.length - 1;

      // Intensity affects frost amount, spread rate
      const frostBase = 0.3 + iceIntensity * 0.7;
      const frost = Math.floor(maxColor * frostBase);
      const spreadRate = 2.5 + iceIntensity * 1.5;  // 2.5 to 4.0
      const crystallizeChance = 0.2 + iceIntensity * 0.3;  // 0.2 to 0.5

      // Update TOP row (frost source) - ice grows from top
      for (let x = 0; x < ICE_WIDTH; x++) {
        // Crystalline pattern - some columns freeze more than others
        const columnFactor = (Math.sin(x * 0.3) + 1) * 0.3 + 0.4;  // 0.4 to 1.0
        const frostAmount = Math.floor(frost * columnFactor);
        icePixels[x] = Math.floor(Math.random() * frostAmount * 0.4) + Math.floor(frostAmount * 0.6);
      }

      // Propagate ice DOWNWARD (opposite of fire)
      for (let y = ICE_HEIGHT - 1; y > 0; y--) {
        for (let x = 0; x < ICE_WIDTH; x++) {
          const srcIdx = (y - 1) * ICE_WIDTH + x;
          const pixel = icePixels[srcIdx];

          if (pixel === 0) {
            // Small chance to spontaneously crystallize if neighbor has ice
            const leftIdx = srcIdx - 1;
            const rightIdx = srcIdx + 1;
            const hasNeighbor = (x > 0 && icePixels[leftIdx] > 5) || (x < ICE_WIDTH - 1 && icePixels[rightIdx] > 5);

            if (hasNeighbor && Math.random() < crystallizeChance * 0.1) {
              icePixels[y * ICE_WIDTH + x] = Math.floor(Math.random() * 10) + 5;
            } else {
              icePixels[y * ICE_WIDTH + x] = 0;
            }
          } else {
            // Ice decay/melt (slower than fire)
            const decay = Math.floor(Math.random() * spreadRate);

            // Branching crystalline spread
            let drift = 0;
            if (Math.random() < crystallizeChance) {
              drift = Math.floor(Math.random() * 3) - 1;  // -1, 0, or 1
            }
            const dstX = Math.min(ICE_WIDTH - 1, Math.max(0, x + drift));
            const dstIdx = y * ICE_WIDTH + dstX;

            // Ice accumulates rather than just replacing
            const newValue = Math.max(0, pixel - decay);
            icePixels[dstIdx] = Math.max(icePixels[dstIdx], newValue);
          }
        }
      }

      // Add occasional sparkle/glint effect
      if (Math.random() < iceIntensity * 0.02) {
        const sparkleX = Math.floor(Math.random() * ICE_WIDTH);
        const sparkleY = Math.floor(Math.random() * ICE_HEIGHT * 0.7);
        if (icePixels[sparkleY * ICE_WIDTH + sparkleX] > 10) {
          icePixels[sparkleY * ICE_WIDTH + sparkleX] = maxColor;  // Bright sparkle
        }
      }
    }

    function renderIce() {
      const data = iceImageData.data;

      for (let y = 0; y < ICE_HEIGHT; y++) {
        for (let x = 0; x < ICE_WIDTH; x++) {
          const iceIdx = y * ICE_WIDTH + x;
          const colorIdx = Math.min(icePixels[iceIdx], ICE_PALETTE.length - 1);
          const color = ICE_PALETTE[colorIdx] || ICE_PALETTE[0];

          const pixelIdx = iceIdx * 4;
          data[pixelIdx] = color[0];
          data[pixelIdx + 1] = color[1];
          data[pixelIdx + 2] = color[2];
          data[pixelIdx + 3] = color[3];
        }
      }

      iceCtx.putImageData(iceImageData, 0, 0);
    }

    // Spawn frost particles (falling snowflakes/ice crystals)
    function spawnFrostParticles(count = 10) {
      if (!settings.particles) return;

      for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        p.className = 'frost-particle';

        const size = 4 + Math.random() * 8;
        const duration = 2 + Math.random() * 2;
        const startX = Math.random() * 100;

        p.style.cssText = `
          width: ${size}px;
          height: ${size}px;
          left: ${startX}%;
          top: 0;
          animation-duration: ${duration}s;
          animation-delay: ${Math.random() * 0.5}s;
        `;

        particlesContainer.appendChild(p);

        // Remove after animation
        setTimeout(() => p.remove(), (duration + 0.5) * 1000);
      }
    }

    function updateAmbientEffects(playrate) {
      // Fire zone: playrate >= fire threshold
      if (playrate >= settings.fireThreshold) {
        // Stop ice if it was running
        stopAmbientIce();

        // Calculate fire intensity proportional to playrate
        // Fire threshold (e.g. 1.3x) = intensity 0.1 (small flames)
        // 2.0x = intensity ~0.4 (medium flames)
        // 3.0x = intensity ~0.7 (large flames)
        // 4.0x = intensity 1.0 (maximum inferno)
        const minRate = settings.fireThreshold;
        const maxRate = 4.0;  // Max playrate supported

        // Non-linear scaling - fire grows faster at higher speeds
        const normalized = (playrate - minRate) / (maxRate - minRate);
        const intensity = Math.min(1, 0.1 + Math.pow(normalized, 0.7) * 0.9);

        startAmbientFire(intensity);
      }
      // Ice zone: playrate <= ice threshold
      else if (playrate <= settings.iceThreshold) {
        // Stop fire if it was running
        stopAmbientFire();

        // Calculate ice intensity proportional to how slow
        // Ice threshold (e.g. 0.8x) = intensity 0.1 (light frost)
        // 0.6x = intensity ~0.5 (medium ice)
        // 0.5x = intensity 1.0 (maximum freeze)
        const maxRate = settings.iceThreshold;
        const minRate = 0.25;  // Min playrate supported

        // Non-linear scaling - ice grows faster at lower speeds
        const normalized = (maxRate - playrate) / (maxRate - minRate);
        const intensity = Math.min(1, 0.1 + Math.pow(normalized, 0.7) * 0.9);

        startAmbientIce(intensity);

        // Spawn frost particles occasionally at high intensity
        if (intensity >= 0.5 && Math.random() < 0.02) {
          spawnFrostParticles(Math.floor(intensity * 5));
        }
      }
      // Normal zone: no effects
      else {
        stopAmbientFire();
        stopAmbientIce();
      }
    }

    // ============ AUTO-RESET COUNTDOWN ============
    const countdownOverlay = document.getElementById('countdownOverlay');
    const countdownNumber = document.getElementById('countdownNumber');
    const countdownBar = document.getElementById('countdownBar');
    const countdownBarFill = document.getElementById('countdownBarFill');

    let countdownTimer = null;
    let countdownEndTime = 0;
    let autoResetEnabled = false; // Will be updated from bot config
    let autoResetDelay = 60; // Will be updated from bot config
    let showCountdownAt = 10; // Show countdown when this many seconds remain

    function startCountdown(delaySeconds) {
      cancelCountdown();
      autoResetDelay = delaySeconds;
      countdownEndTime = Date.now() + (delaySeconds * 1000);
      countdownTimer = setInterval(updateCountdown, 100);
    }

    function cancelCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
      countdownOverlay.classList.remove('active');
      countdownNumber.classList.remove('urgent');
      countdownBar.classList.remove('urgent');
    }

    function updateCountdown() {
      const remaining = Math.max(0, countdownEndTime - Date.now()) / 1000;

      if (remaining <= 0) {
        cancelCountdown();
        // Reset happened - flash effect
        triggerFlash();
        triggerShake();
        return;
      }

      // Only show countdown in final seconds
      if (remaining <= showCountdownAt) {
        countdownOverlay.classList.add('active');

        const displaySeconds = Math.ceil(remaining);
        countdownNumber.textContent = displaySeconds;

        // Progress bar
        const progress = (remaining / showCountdownAt) * 100;
        countdownBarFill.style.width = progress + '%';

        // Urgent mode in final 3 seconds
        if (remaining <= 3) {
          countdownNumber.classList.add('urgent');
          countdownBar.classList.add('urgent');
        } else {
          countdownNumber.classList.remove('urgent');
          countdownBar.classList.remove('urgent');
        }
      } else {
        countdownOverlay.classList.remove('active');
      }
    }

    function addToFeed(oldRate, newRate, username, action, avatarUrl) {
      const diff = newRate - oldRate;
      if (Math.abs(diff) < 0.01 && !username) return;

      const item = document.createElement('div');
      item.className = 'feed-item ' + (diff > 0 ? 'speed-up' : 'slow-down');

      const direction = diff > 0 ? '+' : '';
      const actionIcons = {
        speedUp: '',
        slowDown: '',
        chaos: '',
        reset: ''
      };
      const icon = actionIcons[action] || (diff > 0 ? '' : '');
      const displayName = username || 'Unknown';

      // Use provided avatar or default
      const avatar = avatarUrl || DEFAULT_AVATAR;

      // Create elements properly to avoid inline handler issues
      const avatarImg = document.createElement('img');
      avatarImg.className = 'user-avatar';
      avatarImg.src = avatar;
      avatarImg.alt = displayName;
      avatarImg.onerror = function() { handleAvatarError(this); };

      const feedContent = document.createElement('div');
      feedContent.className = 'feed-content';
      feedContent.innerHTML = `
        <div class="change-header">
          <span class="change-amount">${icon} ${direction}${(diff * 100).toFixed(0)}%</span>
        </div>
        <div class="change-user">${displayName}</div>
        <div class="change-rate">${newRate.toFixed(2)}x</div>
        <div class="change-time">${new Date().toLocaleTimeString()}</div>
      `;

      item.appendChild(avatarImg);
      item.appendChild(feedContent);
      changeFeed.insertBefore(item, changeFeed.firstChild);

      // Keep only last 4
      while (changeFeed.children.length > 4) {
        changeFeed.removeChild(changeFeed.lastChild);
      }

      // Auto-hide after 4 seconds
      setTimeout(() => {
        if (item.parentNode) {
          item.classList.add('slide-out');
          // Remove from DOM after animation completes
          setTimeout(() => {
            if (item.parentNode) {
              item.remove();
            }
          }, 500);
        }
      }, 4000);
    }

    // ============ GAUGE UPDATE ============
    function updateGauge(playrate) {
      // Map playrate (0.5 - 2.0) to angle (-90 to 90 degrees)
      const minRate = 0.5, maxRate = 2.0;
      const clampedRate = Math.max(minRate, Math.min(maxRate, playrate));
      const normalized = (clampedRate - minRate) / (maxRate - minRate);
      const angle = -90 + (normalized * 180);

      gaugeNeedle.style.transform = `rotate(${angle}deg)`;

      // Color based on zone
      let color;
      if (playrate >= settings.fireThreshold) {
        color = 'var(--fire-orange)';
      } else if (playrate <= settings.iceThreshold) {
        color = 'var(--ice-blue)';
      } else if (playrate > 1.1) {
        color = 'var(--neon-yellow)';
      } else if (playrate < 0.9) {
        color = 'var(--neon-blue)';
      } else {
        color = 'var(--neon-green)';
      }

      gaugeFill.style.stroke = color;

      // Arc fill amount
      const arcLength = 455;
      const fillAmount = arcLength * (1 - normalized);
      gaugeFill.style.strokeDashoffset = fillAmount;
    }

    function updatePlayrateBar(playrate) {
      // Map 0.5-2.0 to 0-100%
      const minRate = 0.5, maxRate = 2.0;
      const normalized = (playrate - minRate) / (maxRate - minRate);
      const percent = Math.max(0, Math.min(100, normalized * 100));
      playrateMarker.style.left = percent + '%';
    }

    function updatePlayrateDisplay(playrate) {
      playrateValue.textContent = playrate.toFixed(2) + 'x';

      let color;
      if (playrate >= settings.fireThreshold) {
        color = 'var(--fire-orange)';
      } else if (playrate <= settings.iceThreshold) {
        color = 'var(--ice-blue)';
      } else {
        color = 'var(--neon-green)';
      }
      playrateValue.style.color = color;
    }

    // ============ BEAT UPDATE ============
    function updateBeat(beat, isDownbeat) {
      beatNumber.textContent = beat;

      beatRing.classList.remove('pulse', 'downbeat');
      void beatRing.offsetWidth;

      if (isDownbeat) {
        beatRing.classList.add('downbeat');
      } else {
        beatRing.classList.add('pulse');
      }

      // Update dots
      const dots = beatDots.querySelectorAll('.beat-dot');
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i < beat);
      });
    }

    // ============ REAPER COMMUNICATION ============
    wwr_start();
    wwr_req_recur("GET/PROJEXTSTATE/Teleprompter/data;TRANSPORT", 16);

    let lastBeat = 0;

    function wwr_onreply(results) {
      for (const line of results.split("\n")) {
        const tok = line.split("\t");
        if (tok.length > 3 && tok[1] === "Teleprompter" && tok[2] === "data") {
          try {
            const d = JSON.parse(tok[3] || '{}');

            const newPlayrate = d.pr || 1;
            const newBpm = d.bpm || 120;
            const newTimeSig = d.ts || '4/4';
            const newBeat = d.b || 1;

            // Playrate change detection
            if (Math.abs(newPlayrate - lastPlayrate) > 0.01) {
              // Check if this change was already handled by bot WebSocket
              const recentBotAction = pendingAction && (Date.now() - pendingAction.time < 2000);
              const matchesBotAction = recentBotAction && Math.abs(newPlayrate - pendingAction.newRate) < 0.02;

              if (!matchesBotAction) {
                // This is a manual change or bot isn't connected - show effects without username
                const wasSpeedUp = newPlayrate > lastPlayrate;

                triggerShake();
                triggerFlash();

                if (wasSpeedUp) {
                  spawnParticles('fire', 30);
                  playrateValue.classList.remove('slow-down');
                  playrateValue.classList.add('speed-up');
                } else {
                  spawnParticles('ice', 30);
                  playrateValue.classList.remove('speed-up');
                  playrateValue.classList.add('slow-down');
                }

                setTimeout(() => {
                  playrateValue.classList.remove('speed-up', 'slow-down');
                }, 300);

                addToFeed(lastPlayrate, newPlayrate, null, null);
              }

              lastPlayrate = newPlayrate;
              pendingAction = null; // Clear after handling
            }

            currentPlayrate = newPlayrate;
            currentBpm = newBpm;
            currentBeat = newBeat;

            // Time sig change
            if (newTimeSig !== currentTimeSig) {
              currentTimeSig = newTimeSig;
              timeSigNum = parseInt(newTimeSig.split('/')[0]) || 4;
              generateBeatDots(timeSigNum);
            }

            // Beat change
            if (newBeat !== lastBeat) {
              updateBeat(newBeat, newBeat === 1);
              lastBeat = newBeat;
            }

          } catch (e) {}
        }
      }

      updateDisplay();
    }

    function updateDisplay() {
      bpmValue.textContent = Math.round(currentBpm);
      timeSigValue.textContent = currentTimeSig;

      // Calculate and display effective tempo (BPM * playrate)
      const calculatedTempo = Math.round(currentBpm * currentPlayrate);
      tempoValue.textContent = calculatedTempo;

      // Color the tempo based on playrate
      tempoValue.classList.remove('fast', 'slow');
      if (currentPlayrate >= settings.fireThreshold) {
        tempoValue.classList.add('fast');
      } else if (currentPlayrate <= settings.iceThreshold) {
        tempoValue.classList.add('slow');
      }

      updatePlayrateDisplay(currentPlayrate);
      updateGauge(currentPlayrate);
      updatePlayrateBar(currentPlayrate);
      updateThresholdEffects(currentPlayrate);
      updateAmbientEffects(currentPlayrate);
    }

    // Initial display
    updateDisplay();

    // ============ BOT WEBSOCKET CONNECTION ============
    let botWs = null;
    let lastSentBpm = 0;
    let pendingAction = null; // Store action info to match with playrate change

    function connectToBot() {
      if (!settings.botUrl) return;

      try {
        botWs = new WebSocket(settings.botUrl);

        botWs.onopen = () => {
          console.log('Connected to Playrate Bot');
          // Send current BPM immediately
          if (currentBpm > 0) {
            sendBpmToBot(currentBpm);
          }
        };

        botWs.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            console.log('Bot message received:', msg.type, msg);

            // Handle action events from bot (with username!)
            if (msg.type === 'actionProcessed' && msg.data) {
              const { action, username, newRate, avatarUrl } = msg.data;
              const oldRate = lastPlayrate;

              // Trigger effects
              triggerShake();
              triggerFlash();

              if (newRate > oldRate) {
                spawnParticles('fire', 30);
                playrateValue.classList.add('speed-up');
              } else {
                spawnParticles('ice', 30);
                playrateValue.classList.add('slow-down');
              }

              setTimeout(() => {
                playrateValue.classList.remove('speed-up', 'slow-down');
              }, 300);

              // Add to feed with username and avatar
              addToFeed(oldRate, newRate, username, action, avatarUrl);

              // Store for REAPER sync
              pendingAction = { username, action, newRate, time: Date.now() };
              lastPlayrate = newRate;

              // Restart countdown if auto-reset is enabled and playrate changed from 1.0
              if (action !== 'reset' && autoResetEnabled && autoResetDelay > 0) {
                startCountdown(autoResetDelay);
              } else if (action === 'reset') {
                cancelCountdown();
              }
            }

            // Handle auto-reset event
            if (msg.type === 'autoReset') {
              cancelCountdown();
              triggerFlash();
              triggerShake();
              spawnParticles('ice', 50); // Cool down effect
              addToFeed(lastPlayrate, msg.data?.rate || 1.0, 'AUTO-RESET', 'reset');
              lastPlayrate = msg.data?.rate || 1.0;
            }

            // Handle config/init to get auto-reset settings
            if (msg.type === 'init' && msg.data?.config?.game?.autoReset) {
              const ar = msg.data.config.game.autoReset;
              autoResetEnabled = ar.enabled || false;
              autoResetDelay = ar.delaySeconds || 60;
            }

            if (msg.type === 'configUpdated' && msg.data?.game?.autoReset) {
              const ar = msg.data.game.autoReset;
              autoResetEnabled = ar.enabled || false;
              autoResetDelay = ar.delaySeconds || 60;
            }

            // ============ TEST MESSAGE HANDLERS ============

            // Test countdown
            if (msg.type === 'testCountdown' && msg.data?.seconds) {
              startCountdown(msg.data.seconds);
            }

            // Cancel test countdown
            if (msg.type === 'testCancelCountdown') {
              cancelCountdown();
            }

            // Test individual visual effects
            if (msg.type === 'testVisualEffect' && msg.data?.effect) {
              switch (msg.data.effect) {
                case 'shake':
                  triggerShake();
                  break;
                case 'flash':
                  triggerFlash();
                  break;
                case 'fireParticles':
                  spawnParticles('fire', 40);
                  break;
                case 'iceParticles':
                  spawnParticles('ice', 40);
                  break;
                case 'ambientFire':
                  startAmbientFire(0.7);
                  break;
                case 'stopAmbient':
                  stopAmbientFire();
                  break;
              }
            }

            // Handle playrate changes from bot (fallback)
            if (msg.type === 'playrateChanged' && msg.data?.rate) {
              // Update display immediately for responsiveness
              currentPlayrate = msg.data.rate;
              updateDisplay();
            }
          } catch (e) {}
        };

        botWs.onclose = () => {
          console.log('Disconnected from bot, reconnecting in 5s...');
          setTimeout(connectToBot, 5000);
        };

        botWs.onerror = (err) => {
          console.error('Bot WebSocket error:', err);
        };
      } catch (e) {
        // WebSocket connection failed - bot probably not running
      }
    }

    function sendBpmToBot(bpm) {
      if (botWs && botWs.readyState === WebSocket.OPEN && bpm !== lastSentBpm) {
        botWs.send(JSON.stringify({ type: 'updateBpm', bpm: bpm }));
        lastSentBpm = bpm;
      }
    }

    // Connect to bot on load
    connectToBot();

    // Send BPM updates when detected from REAPER
    const originalWwrOnreply = wwr_onreply;
    wwr_onreply = function(results) {
      originalWwrOnreply(results);
      // Send BPM to bot if changed
      if (currentBpm > 0 && currentBpm !== lastSentBpm) {
        sendBpmToBot(currentBpm);
      }
    };
  </script>
</body>
</html>
