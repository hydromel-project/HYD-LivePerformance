<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game HUD - Playrate Challenge</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');

    :root {
      --bg-color: #0a0a12;
      --neon-blue: #00f0ff;
      --neon-pink: #ff00ff;
      --neon-green: #00ff88;
      --neon-yellow: #ffff00;
      --neon-orange: #ff8800;
      --neon-red: #ff0044;
      --ice-blue: #88ddff;
      --fire-orange: #ff4400;
      --ui-dark: #1a1a2e;
      --ui-border: #333355;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; }

    body {
      background: var(--bg-color);
      font-family: 'Orbitron', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      perspective: 1000px;
    }

    body.transparent-bg { background: transparent !important; }

    /* Scanlines overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.1) 2px,
        rgba(0, 0, 0, 0.1) 4px
      );
      pointer-events: none;
      z-index: 1000;
    }

    body.no-scanlines::before { display: none; }

    /* Screen shake */
    @keyframes shake {
      0%, 100% { transform: translateX(0) translateY(0); }
      10% { transform: translateX(-10px) translateY(-5px); }
      20% { transform: translateX(10px) translateY(5px); }
      30% { transform: translateX(-8px) translateY(-3px); }
      40% { transform: translateX(8px) translateY(3px); }
      50% { transform: translateX(-5px) translateY(-2px); }
      60% { transform: translateX(5px) translateY(2px); }
      70% { transform: translateX(-3px) translateY(-1px); }
      80% { transform: translateX(3px) translateY(1px); }
      90% { transform: translateX(-1px) translateY(0); }
    }

    .shake { animation: shake 0.5s ease-out; }

    /* Main container */
    .hud-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      max-width: 1000px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      grid-template-rows: auto auto auto;
      gap: 10px;
      padding: 10px;
      z-index: 10;
    }

    /* Settings toggle */
    .settings-toggle {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 201;
      background: var(--ui-dark);
      color: var(--neon-blue);
      border: 2px solid var(--neon-blue);
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      text-transform: uppercase;
      box-shadow: 0 0 10px var(--neon-blue);
    }
    .settings-toggle:hover { background: var(--neon-blue); color: var(--bg-color); }
    .settings-toggle.hidden { display: none; }

    /* Settings Panel */
    .settings-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 350px;
      height: 100%;
      background: var(--ui-dark);
      border-right: 2px solid var(--neon-blue);
      z-index: 200;
      padding: 20px;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      box-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
    }
    .settings-panel.open { transform: translateX(0); }
    .settings-panel.hidden { display: none; }

    .settings-panel h2 {
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      color: var(--neon-pink);
      margin-bottom: 20px;
      text-shadow: 0 0 10px var(--neon-pink);
    }

    .settings-panel h3 {
      font-size: 10px;
      color: var(--neon-blue);
      margin: 20px 0 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .settings-group {
      margin-bottom: 15px;
    }

    .settings-group label {
      display: block;
      font-size: 10px;
      color: #888;
      margin-bottom: 5px;
      text-transform: uppercase;
    }

    .settings-group select,
    .settings-group input[type="number"],
    .settings-group input[type="color"] {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--ui-border);
      border-radius: 4px;
      background: var(--bg-color);
      color: var(--neon-green);
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
    }

    .settings-group input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      color: #ccc;
      font-size: 11px;
    }
    .checkbox-label input { margin-right: 10px; }

    .btn-row {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .btn-row button {
      flex: 1;
      padding: 10px;
      border: 2px solid;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      text-transform: uppercase;
    }

    .btn-save {
      background: transparent;
      border-color: var(--neon-green);
      color: var(--neon-green);
    }
    .btn-save:hover { background: var(--neon-green); color: var(--bg-color); }

    .btn-reset {
      background: transparent;
      border-color: var(--neon-red);
      color: var(--neon-red);
    }
    .btn-reset:hover { background: var(--neon-red); color: var(--bg-color); }

    /* ============ TOP SECTION ============ */
    .top-section {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 15px;
      background: linear-gradient(180deg, rgba(0,240,255,0.1) 0%, transparent 100%);
      border-bottom: 2px solid var(--neon-blue);
    }

    .bpm-display, .tempo-display {
      text-align: center;
    }

    .bpm-label, .tempo-label {
      font-size: 8px;
      color: var(--neon-blue);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .bpm-value {
      font-size: 32px;
      font-weight: 900;
      color: var(--neon-pink);
      text-shadow:
        0 0 10px var(--neon-pink),
        0 0 20px var(--neon-pink);
      line-height: 1;
    }

    .tempo-value {
      font-size: 40px;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow:
        0 0 10px var(--neon-green),
        0 0 20px var(--neon-green);
      line-height: 1;
      transition: color 0.3s ease;
    }

    .tempo-value.fast {
      color: var(--fire-orange);
      text-shadow:
        0 0 10px var(--fire-orange),
        0 0 20px var(--fire-orange);
    }

    .tempo-value.slow {
      color: var(--ice-blue);
      text-shadow:
        0 0 10px var(--ice-blue),
        0 0 20px var(--ice-blue);
    }

    .time-sig-display {
      font-family: 'Press Start 2P', monospace;
      font-size: 18px;
      color: var(--neon-green);
      text-shadow: 0 0 10px var(--neon-green);
      padding: 8px 15px;
      border: 2px solid var(--neon-green);
      border-radius: 6px;
      background: rgba(0, 255, 136, 0.1);
    }

    /* ============ CENTER - PLAYRATE GAUGE ============ */
    .center-section {
      grid-column: 2;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      position: relative;
      padding-top: 5px;
    }

    .gauge-container {
      position: relative;
      width: 280px;
      height: 160px;
    }

    .gauge-svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    .gauge-bg {
      fill: none;
      stroke: var(--ui-dark);
      stroke-width: 20;
      stroke-linecap: round;
    }

    .gauge-fill {
      fill: none;
      stroke-width: 20;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.3s ease, stroke 0.3s ease;
      filter: drop-shadow(0 0 10px currentColor);
    }

    .gauge-ticks text {
      fill: #666;
      font-size: 12px;
      font-family: 'Orbitron', sans-serif;
    }

    .gauge-needle {
      fill: var(--neon-pink);
      filter: drop-shadow(0 0 10px var(--neon-pink));
      transform-origin: 175px 180px;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .gauge-center-dot {
      fill: var(--neon-blue);
      filter: drop-shadow(0 0 15px var(--neon-blue));
    }

    /* Playrate number display */
    .playrate-display {
      position: absolute;
      bottom: -20px;
      text-align: center;
      width: 100%;
    }

    .playrate-value {
      font-size: 48px;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow:
        0 0 10px currentColor,
        0 0 20px currentColor;
      transition: color 0.3s ease, transform 0.1s ease;
    }

    .playrate-value.speed-up {
      color: var(--fire-orange);
      animation: pulseUp 0.3s ease;
    }

    .playrate-value.slow-down {
      color: var(--ice-blue);
      animation: pulseDown 0.3s ease;
    }

    @keyframes pulseUp {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @keyframes pulseDown {
      0% { transform: scale(1); }
      50% { transform: scale(0.9); }
      100% { transform: scale(1); }
    }

    .playrate-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-top: 3px;
    }

    /* Speed/Slow indicators */
    .speed-indicator {
      position: absolute;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s ease;
      text-shadow: 0 0 15px currentColor;
    }

    .speed-indicator.fast {
      top: 10px;
      right: -60px;
      color: var(--fire-orange);
    }

    .speed-indicator.slow {
      top: 10px;
      left: -60px;
      color: var(--ice-blue);
    }

    .speed-indicator.active { opacity: 1; }

    /* ============ LEFT - BEAT INDICATOR ============ */
    .left-section {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      gap: 10px;
      padding-top: 10px;
    }

    .beat-ring-container {
      position: relative;
      width: 100px;
      height: 100px;
    }

    .beat-ring {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid var(--ui-border);
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle, rgba(0,240,255,0.1) 0%, transparent 70%);
      transition: border-color 0.1s ease, box-shadow 0.1s ease;
    }

    .beat-ring.pulse {
      border-color: var(--neon-blue);
      box-shadow:
        0 0 20px var(--neon-blue),
        0 0 40px var(--neon-blue),
        inset 0 0 30px rgba(0, 240, 255, 0.3);
    }

    .beat-ring.downbeat {
      border-color: var(--neon-pink);
      box-shadow:
        0 0 30px var(--neon-pink),
        0 0 60px var(--neon-pink),
        inset 0 0 40px rgba(255, 0, 255, 0.3);
    }

    .beat-number {
      font-family: 'Press Start 2P', monospace;
      font-size: 32px;
      color: var(--neon-blue);
      text-shadow: 0 0 15px var(--neon-blue);
      transition: color 0.1s ease, transform 0.05s ease;
    }

    .beat-ring.pulse .beat-number {
      transform: scale(1.1);
    }

    .beat-ring.downbeat .beat-number {
      color: var(--neon-pink);
      text-shadow: 0 0 30px var(--neon-pink);
      transform: scale(1.2);
    }

    /* Beat dots */
    .beat-dots {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }

    .beat-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--ui-dark);
      border: 2px solid var(--ui-border);
      transition: all 0.1s ease;
    }

    .beat-dot.active {
      background: var(--neon-blue);
      border-color: var(--neon-blue);
      box-shadow: 0 0 10px var(--neon-blue);
    }

    .beat-dot.downbeat-dot {
      width: 18px;
      height: 18px;
    }

    .beat-dot.downbeat-dot.active {
      background: var(--neon-pink);
      border-color: var(--neon-pink);
      box-shadow: 0 0 15px var(--neon-pink);
    }

    /* ============ RIGHT - CHANGE FEED ============ */
    .right-section {
      display: flex;
      flex-direction: column;
      gap: 5px;
      padding-top: 5px;
      max-height: 200px;
      overflow: hidden;
    }

    .feed-title {
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      color: var(--neon-pink);
      text-transform: uppercase;
      letter-spacing: 2px;
      padding-bottom: 5px;
      border-bottom: 1px solid var(--ui-border);
      flex-shrink: 0;
    }

    .change-feed {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 180px;
    }

    .feed-item {
      background: var(--ui-dark);
      border-left: 3px solid var(--neon-blue);
      padding: 8px 10px;
      border-radius: 0 6px 6px 0;
      animation: slideIn 0.3s ease;
      font-size: 10px;
      display: flex;
      gap: 8px;
      align-items: flex-start;
    }

    .feed-item.speed-up { border-color: var(--fire-orange); }
    .feed-item.slow-down { border-color: var(--ice-blue); }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; max-height: 100px; margin-bottom: 8px; }
      to { transform: translateX(100%); opacity: 0; max-height: 0; margin-bottom: 0; }
    }

    .feed-item.slide-out {
      animation: slideOut 0.5s ease forwards;
    }

    .feed-item .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid var(--neon-pink);
      box-shadow: 0 0 8px var(--neon-pink);
      flex-shrink: 0;
      object-fit: cover;
      background: var(--ui-border);
    }

    .feed-item .feed-content {
      flex: 1;
      min-width: 0;
    }

    .feed-item .change-header {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 2px;
    }

    .feed-item .change-amount {
      font-weight: 700;
      font-size: 14px;
    }

    .feed-item.speed-up .change-amount { color: var(--fire-orange); }
    .feed-item.slow-down .change-amount { color: var(--ice-blue); }

    .feed-item .change-user {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      color: var(--neon-pink);
      text-shadow: 0 0 6px var(--neon-pink);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .feed-item .change-rate {
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: var(--neon-green);
      text-shadow: 0 0 8px var(--neon-green);
      margin: 3px 0;
    }

    .feed-item.speed-up .change-rate { color: var(--fire-orange); text-shadow: 0 0 8px var(--fire-orange); }
    .feed-item.slow-down .change-rate { color: var(--ice-blue); text-shadow: 0 0 8px var(--ice-blue); }

    .feed-item .change-time {
      font-size: 8px;
      color: #666;
    }

    /* ============ BOTTOM - PLAYRATE BAR ============ */
    .bottom-section {
      grid-column: 1 / -1;
      padding: 5px 10px;
    }

    .playrate-bar-container {
      position: relative;
      height: 25px;
      background: var(--ui-dark);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--ui-border);
    }

    .playrate-bar-bg {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
    }

    .bar-zone {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 8px;
      color: rgba(255,255,255,0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
      border-right: 1px solid var(--ui-border);
    }

    .bar-zone:last-child { border-right: none; }
    .bar-zone.ice { background: rgba(136, 221, 255, 0.1); }
    .bar-zone.normal { background: rgba(0, 255, 136, 0.1); }
    .bar-zone.fire { background: rgba(255, 68, 0, 0.1); }

    .playrate-marker {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 35px;
      background: var(--neon-pink);
      border-radius: 3px;
      box-shadow: 0 0 15px var(--neon-pink);
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 10;
    }

    .bar-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      padding: 0 10px;
      font-size: 9px;
      color: #666;
    }

    /* ============ PARTICLE EFFECTS ============ */
    .particles-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      overflow: hidden;
      contain: strict;
      will-change: contents;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      contain: layout style;
      will-change: transform, opacity;
      backface-visibility: hidden;
      transform: translate3d(0, 0, 0);
    }

    .particle.fire {
      background: radial-gradient(circle, var(--fire-orange) 0%, transparent 70%);
    }

    .particle.ice {
      background: radial-gradient(circle, var(--ice-blue) 0%, transparent 70%);
    }

    @keyframes particleFire {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
      100% { transform: translate3d(0, -150px, 0) scale(0); opacity: 0; }
    }

    @keyframes particleIce {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
      100% { transform: translate3d(0, 150px, 0) scale(0); opacity: 0; }
    }

    /* ============ REALISTIC FIRE - 60FPS GPU ACCELERATED ============ */

    /* Base flame particle - teardrop shape */
    .particle.flame {
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      mix-blend-mode: screen;
      contain: layout style paint;
      filter: none; /* No blur for 60fps */
    }

    /* Core flame - hottest, white-yellow center */
    .particle.flame.core {
      background: radial-gradient(ellipse at 50% 70%,
        rgba(255, 255, 255, 0.95) 0%,
        rgba(255, 255, 200, 0.9) 15%,
        rgba(255, 220, 100, 0.8) 30%,
        rgba(255, 180, 50, 0.6) 50%,
        rgba(255, 120, 0, 0.3) 70%,
        transparent 100%);
    }

    /* Inner flame - orange-yellow */
    .particle.flame.inner {
      background: radial-gradient(ellipse at 50% 65%,
        rgba(255, 200, 80, 0.85) 0%,
        rgba(255, 150, 30, 0.7) 30%,
        rgba(255, 100, 0, 0.5) 55%,
        rgba(200, 50, 0, 0.25) 75%,
        transparent 100%);
    }

    /* Outer flame - red-orange */
    .particle.flame.outer {
      background: radial-gradient(ellipse at 50% 60%,
        rgba(255, 130, 30, 0.7) 0%,
        rgba(255, 80, 0, 0.5) 35%,
        rgba(200, 30, 0, 0.3) 60%,
        rgba(120, 0, 0, 0.1) 80%,
        transparent 100%);
    }

    /* Smoke wisps at top */
    .particle.smoke {
      background: radial-gradient(circle,
        rgba(80, 80, 80, 0.3) 0%,
        rgba(60, 60, 60, 0.15) 40%,
        transparent 70%);
      mix-blend-mode: multiply;
    }

    /* Multiple animation variations for natural look */
    .particle.flame.anim-1 { animation: flameRise1 var(--dur, 1s) ease-out forwards; }
    .particle.flame.anim-2 { animation: flameRise2 var(--dur, 1s) ease-out forwards; }
    .particle.flame.anim-3 { animation: flameRise3 var(--dur, 1s) ease-out forwards; }
    .particle.smoke { animation: smokeRise var(--dur, 1.5s) ease-out forwards; }

    /* Varied flame animations - turbulent motion */
    @keyframes flameRise1 {
      0% { transform: translate3d(0, 0, 0) scale(1, 1) rotate(0deg); opacity: 0.9; }
      20% { transform: translate3d(-8px, -40px, 0) scale(0.95, 1.2) rotate(-5deg); opacity: 1; }
      40% { transform: translate3d(5px, -90px, 0) scale(0.8, 1.0) rotate(3deg); opacity: 0.75; }
      60% { transform: translate3d(-3px, -140px, 0) scale(0.6, 0.7) rotate(-2deg); opacity: 0.45; }
      80% { transform: translate3d(6px, -180px, 0) scale(0.35, 0.4) rotate(4deg); opacity: 0.2; }
      100% { transform: translate3d(0, -220px, 0) scale(0.1, 0.15) rotate(0deg); opacity: 0; }
    }

    @keyframes flameRise2 {
      0% { transform: translate3d(0, 0, 0) scale(1, 1) rotate(0deg); opacity: 0.85; }
      25% { transform: translate3d(10px, -50px, 0) scale(0.9, 1.15) rotate(6deg); opacity: 0.95; }
      50% { transform: translate3d(-6px, -110px, 0) scale(0.7, 0.85) rotate(-4deg); opacity: 0.6; }
      75% { transform: translate3d(4px, -165px, 0) scale(0.4, 0.45) rotate(2deg); opacity: 0.25; }
      100% { transform: translate3d(-2px, -210px, 0) scale(0.15, 0.2) rotate(-1deg); opacity: 0; }
    }

    @keyframes flameRise3 {
      0% { transform: translate3d(0, 0, 0) scale(1, 1) rotate(0deg); opacity: 0.8; }
      15% { transform: translate3d(-5px, -30px, 0) scale(1.05, 1.25) rotate(-3deg); opacity: 0.9; }
      35% { transform: translate3d(8px, -75px, 0) scale(0.85, 0.95) rotate(5deg); opacity: 0.7; }
      55% { transform: translate3d(-4px, -125px, 0) scale(0.55, 0.6) rotate(-3deg); opacity: 0.4; }
      80% { transform: translate3d(3px, -175px, 0) scale(0.3, 0.35) rotate(2deg); opacity: 0.15; }
      100% { transform: translate3d(0, -200px, 0) scale(0.1, 0.1) rotate(0deg); opacity: 0; }
    }

    @keyframes smokeRise {
      0% { transform: translate3d(0, -150px, 0) scale(0.5); opacity: 0; }
      20% { transform: translate3d(5px, -180px, 0) scale(0.8); opacity: 0.2; }
      60% { transform: translate3d(-8px, -250px, 0) scale(1.2); opacity: 0.15; }
      100% { transform: translate3d(10px, -320px, 0) scale(1.8); opacity: 0; }
    }

    /* Canvas fire simulation */
    #fireCanvas {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 150px;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.3s, height 0.5s ease-out;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #fireCanvas.active {
      opacity: 1;
    }

    /* Fire intensity text effects */
    .fire-text-effect {
      transition: text-shadow 0.3s, color 0.3s, transform 0.1s;
    }

    .fire-text-effect.intensity-low {
      text-shadow:
        0 0 10px currentColor,
        0 0 20px rgba(255, 100, 0, 0.3);
    }

    .fire-text-effect.intensity-medium {
      text-shadow:
        0 0 15px currentColor,
        0 0 30px rgba(255, 100, 0, 0.5),
        0 0 50px rgba(255, 50, 0, 0.3);
      animation: fireTextPulse 0.5s ease-in-out infinite alternate;
    }

    .fire-text-effect.intensity-high {
      color: #ffcc00 !important;
      text-shadow:
        0 0 10px #ff8800,
        0 0 20px #ff4400,
        0 0 40px #ff2200,
        0 0 60px #ff0000,
        0 0 80px rgba(255, 0, 0, 0.5);
      animation: fireTextIntense 0.15s ease-in-out infinite alternate;
    }

    .fire-text-effect.intensity-max {
      color: #ffffff !important;
      text-shadow:
        0 0 10px #ffff88,
        0 0 20px #ffcc00,
        0 0 40px #ff8800,
        0 0 60px #ff4400,
        0 0 100px #ff0000,
        0 0 150px rgba(255, 0, 0, 0.8);
      animation: fireTextMax 0.1s ease-in-out infinite alternate;
    }

    @keyframes fireTextPulse {
      0% { transform: scale(1); filter: brightness(1); }
      100% { transform: scale(1.02); filter: brightness(1.1); }
    }

    @keyframes fireTextIntense {
      0% { transform: scale(1) translateY(0); filter: brightness(1.1); }
      100% { transform: scale(1.03) translateY(-1px); filter: brightness(1.3); }
    }

    @keyframes fireTextMax {
      0% { transform: scale(1) translateY(0); filter: brightness(1.2); }
      50% { transform: scale(1.05) translateY(-2px); filter: brightness(1.5); }
      100% { transform: scale(1.02) translateY(-1px); filter: brightness(1.3); }
    }

    /* Fire glow with flickering */
    .fire-glow {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: linear-gradient(to top,
        rgba(255, 100, 0, 0.35) 0%,
        rgba(255, 60, 0, 0.2) 30%,
        rgba(255, 30, 0, 0.08) 60%,
        transparent 100%);
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      will-change: opacity;
      contain: strict;
    }

    .fire-glow.active {
      opacity: 1;
      animation: glowFlicker 0.15s ease-in-out infinite alternate;
    }

    @keyframes glowFlicker {
      0% { opacity: 0.85; }
      100% { opacity: 1; }
    }

    /* ============ ICE/FROST EFFECTS ============ */

    /* Canvas snow simulation */
    #iceCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.5s;
    }

    #iceCanvas.active {
      opacity: 1;
    }

    /* Ice intensity text effects */
    .ice-text-effect {
      transition: text-shadow 0.3s, color 0.3s, transform 0.1s, -webkit-text-stroke 0.3s;
    }

    .ice-text-effect.intensity-low {
      color: #e0f4ff !important;
      -webkit-text-stroke: 1px rgba(100, 180, 255, 0.4);
      text-shadow:
        /* Frost contour outline */
        -1px -1px 0 rgba(180, 220, 255, 0.6),
        1px -1px 0 rgba(180, 220, 255, 0.6),
        -1px 1px 0 rgba(180, 220, 255, 0.6),
        1px 1px 0 rgba(180, 220, 255, 0.6),
        /* Glow */
        0 0 5px #fff,
        0 0 10px #fff,
        0 0 20px rgba(136, 200, 255, 0.5),
        2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .ice-text-effect.intensity-medium {
      color: #ffffff !important;
      -webkit-text-stroke: 1.5px rgba(100, 200, 255, 0.5);
      text-shadow:
        /* Frost contour outline */
        -1px -1px 0 rgba(150, 210, 255, 0.7),
        1px -1px 0 rgba(150, 210, 255, 0.7),
        -1px 1px 0 rgba(150, 210, 255, 0.7),
        1px 1px 0 rgba(150, 210, 255, 0.7),
        0 -2px 0 rgba(200, 235, 255, 0.5),
        /* Glow */
        0 0 5px #fff,
        0 0 15px #b8e8ff,
        0 0 30px rgba(100, 180, 255, 0.6),
        0 0 50px rgba(50, 150, 255, 0.4),
        3px 3px 6px rgba(0, 0, 0, 0.9);
      animation: iceTextPulse 0.8s ease-in-out infinite alternate;
    }

    .ice-text-effect.intensity-high {
      color: #ffffff !important;
      -webkit-text-stroke: 2px rgba(100, 200, 255, 0.6);
      text-shadow:
        /* Frost contour outline - thicker */
        -2px -2px 0 rgba(130, 200, 255, 0.8),
        2px -2px 0 rgba(130, 200, 255, 0.8),
        -2px 2px 0 rgba(130, 200, 255, 0.8),
        2px 2px 0 rgba(130, 200, 255, 0.8),
        0 -2px 0 rgba(180, 230, 255, 0.6),
        0 2px 0 rgba(100, 180, 255, 0.6),
        /* Glow */
        0 0 8px #fff,
        0 0 15px #b8e8ff,
        0 0 25px #66ccff,
        0 0 40px #44aaff,
        0 0 60px #2288ff,
        4px 4px 8px rgba(0, 0, 0, 1);
      animation: iceTextIntense 0.2s ease-in-out infinite alternate;
    }

    .ice-text-effect.intensity-max {
      color: #ffffff !important;
      -webkit-text-stroke: 2.5px rgba(150, 220, 255, 0.7);
      text-shadow:
        /* Frost contour outline - thick icy edge */
        -2px -2px 1px rgba(200, 240, 255, 0.9),
        2px -2px 1px rgba(200, 240, 255, 0.9),
        -2px 2px 1px rgba(200, 240, 255, 0.9),
        2px 2px 1px rgba(200, 240, 255, 0.9),
        -3px 0 1px rgba(150, 220, 255, 0.7),
        3px 0 1px rgba(150, 220, 255, 0.7),
        0 -3px 1px rgba(220, 245, 255, 0.8),
        0 3px 1px rgba(100, 180, 255, 0.7),
        /* Glow */
        0 0 10px #fff,
        0 0 20px #eeffff,
        0 0 35px #bbffff,
        0 0 50px #88ddff,
        0 0 80px #44aaff,
        0 0 120px #0088ff,
        5px 5px 10px rgba(0, 0, 0, 1);
      animation: iceTextMax 0.15s ease-in-out infinite alternate;
    }

    @keyframes iceTextPulse {
      0% { transform: scale(1); filter: brightness(1); }
      100% { transform: scale(0.98); filter: brightness(1.1); }
    }

    @keyframes iceTextIntense {
      0% { transform: scale(1) translateY(0); filter: brightness(1.1); }
      100% { transform: scale(0.97) translateY(1px); filter: brightness(1.2); }
    }

    @keyframes iceTextMax {
      0% { transform: scale(1) translateY(0); filter: brightness(1.2); }
      50% { transform: scale(0.96) translateY(1px); filter: brightness(1.4); }
      100% { transform: scale(0.98) translateY(0); filter: brightness(1.3); }
    }

    /* Frozen/shiver effect for text */
    @keyframes iceShiver {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-1px); }
      75% { transform: translateX(1px); }
    }

    .ice-text-effect.intensity-max {
      animation: iceTextMax 0.15s ease-in-out infinite alternate, iceShiver 0.1s linear infinite;
    }

    /* Ice glow from top */
    .ice-glow {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: linear-gradient(to bottom,
        rgba(100, 180, 255, 0.35) 0%,
        rgba(60, 150, 255, 0.2) 30%,
        rgba(30, 120, 255, 0.08) 60%,
        transparent 100%);
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      will-change: opacity;
      contain: strict;
    }

    .ice-glow.active {
      opacity: 1;
      animation: iceGlowPulse 2s ease-in-out infinite alternate;
    }

    @keyframes iceGlowPulse {
      0% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Frost crystal particles */
    .frost-particle {
      position: absolute;
      pointer-events: none;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(136,221,255,0.6) 40%, transparent 70%);
      border-radius: 50%;
      animation: frostFall linear forwards;
    }

    @keyframes frostFall {
      0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
      100% { transform: translateY(200px) rotate(180deg) scale(0.3); opacity: 0; }
    }

    /* Water droplet for melting effect */
    @keyframes waterDrip {
      0% {
        transform: translateY(0) scaleY(1);
        opacity: 0.8;
      }
      20% {
        transform: translateY(50px) scaleY(1.2);
        opacity: 0.9;
      }
      80% {
        transform: translateY(300px) scaleY(1.5);
        opacity: 0.6;
      }
      100% {
        transform: translateY(400px) scaleY(0.5);
        opacity: 0;
      }
    }

    .water-droplet {
      filter: blur(0.5px);
    }

    /* Ice crack overlay effect */
    .ice-crack-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      opacity: 0;
      background:
        radial-gradient(ellipse at 20% 10%, rgba(255,255,255,0.1) 0%, transparent 30%),
        radial-gradient(ellipse at 80% 15%, rgba(200,230,255,0.1) 0%, transparent 25%),
        radial-gradient(ellipse at 50% 5%, rgba(180,220,255,0.15) 0%, transparent 35%);
      transition: opacity 0.5s;
    }

    .ice-crack-overlay.active {
      opacity: 1;
    }

    /* Heat shimmer effect above fire */
    .heat-shimmer {
      position: fixed;
      bottom: 80px;
      left: 0;
      right: 0;
      height: 200px;
      background: transparent;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      will-change: opacity;
    }

    .heat-shimmer.active {
      opacity: 1;
      animation: shimmer 0.1s linear infinite;
    }

    @keyframes shimmer {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(1px); }
    }

    /* Ember sparks */
    .particle.ember {
      border-radius: 50%;
      background: #ffdd44;
      box-shadow: 0 0 3px #ff8800, 0 0 6px #ff4400;
    }

    @keyframes emberFloat {
      0% { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
      30% { transform: translate3d(15px, -80px, 0) scale(0.9); opacity: 0.9; }
      60% { transform: translate3d(-10px, -180px, 0) scale(0.6); opacity: 0.6; }
      100% { transform: translate3d(20px, -280px, 0) scale(0.2); opacity: 0; }
    }

    /* Auto-reset countdown overlay */
    .countdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 300;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .countdown-overlay.active {
      opacity: 1;
    }

    .countdown-label {
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      color: var(--neon-yellow);
      text-shadow: 0 0 20px var(--neon-yellow);
      letter-spacing: 4px;
      margin-bottom: 20px;
      animation: countdownPulse 1s ease-in-out infinite;
    }

    .countdown-number {
      font-family: 'Orbitron', sans-serif;
      font-size: 120px;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow:
        0 0 20px var(--neon-green),
        0 0 40px var(--neon-green),
        0 0 80px var(--neon-green);
      line-height: 1;
      animation: countdownBounce 1s ease-in-out infinite;
    }

    .countdown-number.urgent {
      color: var(--neon-red);
      text-shadow:
        0 0 20px var(--neon-red),
        0 0 40px var(--neon-red),
        0 0 80px var(--neon-red);
      animation: countdownUrgent 0.5s ease-in-out infinite;
    }

    @keyframes countdownPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    @keyframes countdownBounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes countdownUrgent {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    .countdown-bar {
      width: 300px;
      height: 8px;
      background: var(--ui-dark);
      border-radius: 4px;
      margin-top: 30px;
      overflow: hidden;
      border: 2px solid var(--neon-green);
      box-shadow: 0 0 15px var(--neon-green);
    }

    .countdown-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-green), var(--neon-yellow));
      transition: width 1s linear;
      box-shadow: 0 0 10px var(--neon-green);
    }

    .countdown-bar.urgent {
      border-color: var(--neon-red);
      box-shadow: 0 0 15px var(--neon-red);
    }

    .countdown-bar.urgent .countdown-bar-fill {
      background: linear-gradient(90deg, var(--neon-red), var(--neon-yellow));
    }

    /* ============ THRESHOLD EFFECTS ============ */
    .effect-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .effect-overlay.fire-effect {
      background: radial-gradient(ellipse at bottom, rgba(255,68,0,0.3) 0%, transparent 70%);
      border-bottom: 5px solid var(--fire-orange);
      box-shadow: inset 0 -100px 100px -50px rgba(255,68,0,0.4);
    }

    .effect-overlay.ice-effect {
      background: radial-gradient(ellipse at top, rgba(136,221,255,0.3) 0%, transparent 70%);
      border-top: 5px solid var(--ice-blue);
      box-shadow: inset 0 100px 100px -50px rgba(136,221,255,0.4);
    }

    .effect-overlay.active { opacity: 1; }

    /* Flash effect */
    .flash-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 150;
      background: white;
      opacity: 0;
    }

    .flash-overlay.flash {
      animation: flashAnim 0.2s ease-out;
    }

    @keyframes flashAnim {
      0% { opacity: 0.5; }
      100% { opacity: 0; }
    }

    /* URL output */
    .url-output {
      margin-top: 20px;
      padding: 15px;
      background: var(--bg-color);
      border: 1px solid var(--ui-border);
      border-radius: 8px;
    }

    .url-output input {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid var(--ui-border);
      border-radius: 4px;
      background: var(--ui-dark);
      color: var(--neon-green);
      font-family: monospace;
      font-size: 10px;
    }

    .url-output button {
      width: 100%;
      padding: 10px;
      border: 2px solid var(--neon-blue);
      border-radius: 5px;
      background: transparent;
      color: var(--neon-blue);
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      cursor: pointer;
    }
    .url-output button:hover { background: var(--neon-blue); color: var(--bg-color); }

    .copied-msg {
      text-align: center;
      color: var(--neon-green);
      font-size: 10px;
      margin-top: 8px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .copied-msg.show { opacity: 1; }

    /* ============ MILESTONES & ACHIEVEMENTS ============ */
    .milestone-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      z-index: 1000;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: none;
    }

    .milestone-popup.active {
      animation: milestoneAppear 2.5s ease-out forwards;
    }

    .milestone-popup .milestone-icon {
      font-size: 80px;
      margin-bottom: 10px;
      animation: milestoneIconPulse 0.5s ease-in-out infinite alternate;
    }

    .milestone-popup .milestone-title {
      font-family: 'Press Start 2P', monospace;
      font-size: 32px;
      color: #fff;
      text-shadow:
        0 0 10px currentColor,
        0 0 20px currentColor,
        0 0 40px currentColor,
        4px 4px 0 #000;
      margin-bottom: 8px;
    }

    .milestone-popup .milestone-subtitle {
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      color: #aaa;
      text-shadow: 2px 2px 0 #000;
    }

    /* Speed milestone colors - FAST */
    .milestone-popup.speed-2x .milestone-title { color: #ffaa00; }
    .milestone-popup.speed-3x .milestone-title { color: #ff6600; }
    .milestone-popup.speed-4x .milestone-title { color: #ff0066; }
    .milestone-popup.ludicrous .milestone-title {
      color: #ff00ff;
      animation: ludicrousText 0.1s linear infinite;
    }

    /* Speed milestone colors - SLOW */
    .milestone-popup.slow-half .milestone-title { color: #66ddff; }
    .milestone-popup.slow-quarter .milestone-title { color: #44aaff; }
    .milestone-popup.frozen .milestone-title {
      color: #aaeeff;
      animation: frozenText 0.5s ease-in-out infinite alternate;
    }

    @keyframes frozenText {
      0% {
        color: #aaeeff;
        text-shadow: 0 0 20px #88ddff, 0 0 40px #44aaff, 4px 4px 0 #000;
        transform: scale(1);
      }
      100% {
        color: #ffffff;
        text-shadow: 0 0 30px #aaeeff, 0 0 60px #66ccff, 4px 4px 0 #000;
        transform: scale(1.02);
      }
    }

    @keyframes milestoneAppear {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      15% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
      25% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      75% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    }

    @keyframes milestoneIconPulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.2); }
    }

    @keyframes ludicrousText {
      0% { color: #ff00ff; text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff; }
      25% { color: #00ffff; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
      50% { color: #ffff00; text-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00; }
      75% { color: #ff0000; text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; }
      100% { color: #ff00ff; text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff; }
    }

    /* Celebration particles burst */
    .celebration-particle {
      position: fixed;
      pointer-events: none;
      z-index: 999;
      font-size: 24px;
      animation: celebrationBurst 1.5s ease-out forwards;
    }

    @keyframes celebrationBurst {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0.5) rotate(var(--rot));
      }
    }

    /* Session stats display */
    .session-stats {
      position: fixed;
      bottom: 80px;
      left: 20px;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.6);
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      z-index: 50;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .session-stats.visible {
      opacity: 1;
    }

    .session-stats .stat-line {
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .session-stats .stat-icon {
      font-size: 12px;
    }

    .session-stats .stat-value {
      color: var(--neon-cyan);
    }

    .session-stats .stat-highlight {
      color: var(--neon-pink);
      animation: statPulse 2s ease-in-out infinite;
    }

    @keyframes statPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    /* Ludicrous speed screen effect */
    .ludicrous-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 500;
      opacity: 0;
      background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 255, 0.1) 100%);
      transition: opacity 0.3s;
    }

    .ludicrous-overlay.active {
      opacity: 1;
      animation: ludicrousScreen 0.15s linear infinite;
    }

    @keyframes ludicrousScreen {
      0% { background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 255, 0.15) 100%); }
      33% { background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 255, 255, 0.15) 100%); }
      66% { background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 255, 0, 0.15) 100%); }
      100% { background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 0, 255, 0.15) 100%); }
    }

    /* Speed lines for ludicrous mode */
    .speed-lines {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 499;
      opacity: 0;
      overflow: hidden;
    }

    .speed-lines.active {
      opacity: 1;
    }

    .speed-line {
      position: absolute;
      height: 2px;
      background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.8), transparent);
      animation: speedLineMove 0.3s linear infinite;
    }

    @keyframes speedLineMove {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100vw); }
    }

    /* ============ COMBO SYSTEM ============ */
    .combo-display {
      position: fixed;
      top: 50%;
      right: 30px;
      transform: translateY(-50%);
      text-align: right;
      font-family: 'Press Start 2P', monospace;
      z-index: 200;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .combo-display.active {
      opacity: 1;
    }

    .combo-count {
      font-size: 48px;
      color: #fff;
      text-shadow:
        0 0 10px currentColor,
        0 0 20px currentColor,
        3px 3px 0 #000;
      line-height: 1;
    }

    .combo-label {
      font-size: 14px;
      color: #ffaa00;
      text-shadow: 2px 2px 0 #000;
      margin-top: 5px;
    }

    .combo-bonus {
      font-size: 12px;
      color: #00ff88;
      text-shadow: 2px 2px 0 #000;
      margin-top: 8px;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s, transform 0.3s;
    }

    .combo-bonus.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* Combo intensity colors */
    .combo-display.combo-hot .combo-count { color: #ffaa00; }
    .combo-display.combo-fire .combo-count { color: #ff6600; }
    .combo-display.combo-blazing .combo-count {
      color: #ff0066;
      animation: comboBlaze 0.2s ease-in-out infinite alternate;
    }
    .combo-display.combo-legendary .combo-count {
      animation: comboLegendary 0.15s linear infinite;
    }

    .combo-display.combo-ice .combo-count { color: #66ddff; }
    .combo-display.combo-frozen .combo-count { color: #44aaff; }
    .combo-display.combo-glacial .combo-count {
      color: #aaeeff;
      animation: comboGlacial 0.3s ease-in-out infinite alternate;
    }

    @keyframes comboBlaze {
      0% { transform: scale(1); filter: brightness(1); }
      100% { transform: scale(1.05); filter: brightness(1.3); }
    }

    @keyframes comboLegendary {
      0% { color: #ff00ff; text-shadow: 0 0 20px #ff00ff, 3px 3px 0 #000; }
      25% { color: #ffff00; text-shadow: 0 0 20px #ffff00, 3px 3px 0 #000; }
      50% { color: #00ffff; text-shadow: 0 0 20px #00ffff, 3px 3px 0 #000; }
      75% { color: #ff0000; text-shadow: 0 0 20px #ff0000, 3px 3px 0 #000; }
      100% { color: #ff00ff; text-shadow: 0 0 20px #ff00ff, 3px 3px 0 #000; }
    }

    @keyframes comboGlacial {
      0% { transform: scale(1); filter: brightness(1); }
      100% { transform: scale(1.03); filter: brightness(1.2); }
    }

    /* Combo popup notification */
    .combo-popup {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      font-family: 'Press Start 2P', monospace;
      font-size: 24px;
      color: #fff;
      text-shadow: 0 0 20px currentColor, 3px 3px 0 #000;
      z-index: 1001;
      pointer-events: none;
      white-space: nowrap;
    }

    .combo-popup.active {
      animation: comboPopup 1.5s ease-out forwards;
    }

    .combo-popup.fire { color: #ff6600; }
    .combo-popup.ice { color: #66ddff; }

    @keyframes comboPopup {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      30% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -70%) scale(0.8); opacity: 0; }
    }

    /* Leaderboard */
    .leaderboard {
      position: fixed;
      bottom: 80px;
      right: 20px;
      font-family: 'Press Start 2P', monospace;
      font-size: 9px;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.3s;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 10px;
      min-width: 180px;
    }

    .leaderboard.visible {
      opacity: 1;
    }

    .leaderboard-title {
      color: #ffaa00;
      text-shadow: 1px 1px 0 #000;
      margin-bottom: 8px;
      text-align: center;
      font-size: 10px;
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .leaderboard-entry:last-child {
      border-bottom: none;
    }

    .leaderboard-rank {
      color: #888;
      width: 20px;
    }

    .leaderboard-rank.gold { color: #ffd700; }
    .leaderboard-rank.silver { color: #c0c0c0; }
    .leaderboard-rank.bronze { color: #cd7f32; }

    .leaderboard-name {
      color: #fff;
      flex: 1;
      margin: 0 8px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .leaderboard-score {
      color: var(--neon-cyan);
    }
  </style>
</head>
<body>
  <button class="settings-toggle" id="settingsToggle">CONFIG</button>

  <div class="settings-panel" id="settingsPanel">
    <h2>GAME HUD CONFIG</h2>

    <h3>Display</h3>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setTransparent">
        Transparent Background
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setScanlines" checked>
        Scanlines Effect
      </label>
    </div>

    <h3>Elements</h3>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowBpm" checked>
        Show BPM
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowTempo" checked>
        Show Calculated Tempo
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowTimeSig" checked>
        Show Time Signature
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowGauge" checked>
        Show Speedometer
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowBar" checked>
        Show Playrate Bar
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowBeat" checked>
        Show Beat Indicator
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setShowFeed" checked>
        Show Change Feed
      </label>
    </div>

    <h3>Effects</h3>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setScreenShake" checked>
        Screen Shake
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setFlash" checked>
        Flash on Change
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setParticles" checked>
        Particle Effects
      </label>
    </div>
    <div class="settings-group">
      <label class="checkbox-label">
        <input type="checkbox" id="setThresholdEffects" checked>
        Fire/Ice Threshold Effects
      </label>
    </div>

    <h3>Thresholds</h3>
    <div class="settings-group">
      <label>Fire Zone (above): <span id="fireThresholdVal">1.3</span>x</label>
      <input type="range" id="setFireThreshold" min="1.1" max="1.8" step="0.1" value="1.3">
    </div>
    <div class="settings-group">
      <label>Ice Zone (below): <span id="iceThresholdVal">0.8</span>x</label>
      <input type="range" id="setIceThreshold" min="0.5" max="0.9" step="0.1" value="0.8">
    </div>

    <div class="btn-row">
      <button class="btn-save" id="saveSettings">SAVE</button>
      <button class="btn-reset" id="resetSettings">RESET</button>
    </div>

    <div class="url-output">
      <label style="color: #666; font-size: 10px;">OBS URL:</label>
      <input type="text" id="generatedUrl" readonly>
      <button id="copyUrl">COPY URL</button>
      <div class="copied-msg" id="copiedMsg">COPIED!</div>
    </div>
  </div>

  <div class="hud-container" id="hudContainer">
    <!-- Top Section: BPM, Calculated Tempo & Time Sig -->
    <div class="top-section">
      <div class="bpm-display" id="bpmSection">
        <div class="bpm-label">BPM</div>
        <div class="bpm-value" id="bpmValue">120</div>
      </div>
      <div class="tempo-display" id="tempoSection">
        <div class="tempo-label">TEMPO</div>
        <div class="tempo-value" id="tempoValue">120</div>
      </div>
      <div class="time-sig-display" id="timeSigSection">
        <span id="timeSigValue">4/4</span>
      </div>
    </div>

    <!-- Left: Beat Indicator -->
    <div class="left-section" id="beatSection">
      <div class="beat-ring-container">
        <div class="beat-ring" id="beatRing">
          <div class="beat-number" id="beatNumber">1</div>
        </div>
      </div>
      <div class="beat-dots" id="beatDots"></div>
    </div>

    <!-- Center: Playrate Gauge -->
    <div class="center-section" id="gaugeSection">
      <div class="speed-indicator slow" id="slowIndicator">SLOW</div>
      <div class="speed-indicator fast" id="fastIndicator">FAST!</div>

      <div class="gauge-container">
        <svg class="gauge-svg" viewBox="0 0 350 220">
          <!-- Background arc -->
          <path class="gauge-bg" d="M 30 180 A 145 145 0 0 1 320 180" />

          <!-- Colored fill arc -->
          <path class="gauge-fill" id="gaugeFill" d="M 30 180 A 145 145 0 0 1 320 180"
                stroke="var(--neon-green)"
                stroke-dasharray="455"
                stroke-dashoffset="227" />

          <!-- Tick marks and labels -->
          <g class="gauge-ticks">
            <text x="25" y="200" text-anchor="middle">0.5x</text>
            <text x="95" y="85" text-anchor="middle">0.75x</text>
            <text x="175" y="55" text-anchor="middle">1.0x</text>
            <text x="255" y="85" text-anchor="middle">1.5x</text>
            <text x="325" y="200" text-anchor="middle">2.0x</text>
          </g>

          <!-- Needle -->
          <polygon class="gauge-needle" id="gaugeNeedle" points="175,60 170,180 180,180" />

          <!-- Center dot -->
          <circle class="gauge-center-dot" cx="175" cy="180" r="15" />
        </svg>
      </div>

      <div class="playrate-display">
        <div class="playrate-value" id="playrateValue">1.00x</div>
        <div class="playrate-label">PLAYRATE</div>
      </div>
    </div>

    <!-- Right: Change Feed -->
    <div class="right-section" id="feedSection">
      <div class="feed-title">CHANGES</div>
      <div class="change-feed" id="changeFeed"></div>
    </div>

    <!-- Bottom: Playrate Bar -->
    <div class="bottom-section" id="barSection">
      <div class="playrate-bar-container">
        <div class="playrate-bar-bg">
          <div class="bar-zone ice">SLOW</div>
          <div class="bar-zone normal">NORMAL</div>
          <div class="bar-zone fire">FAST</div>
        </div>
        <div class="playrate-marker" id="playrateMarker"></div>
      </div>
      <div class="bar-labels">
        <span>0.5x</span>
        <span>1.0x</span>
        <span>2.0x</span>
      </div>
    </div>
  </div>

  <!-- Effect overlays -->
  <div class="effect-overlay fire-effect" id="fireOverlay"></div>
  <div class="effect-overlay ice-effect" id="iceOverlay"></div>
  <div class="flash-overlay" id="flashOverlay"></div>
  <canvas id="fireCanvas"></canvas>
  <canvas id="iceCanvas"></canvas>
  <div class="ice-glow" id="iceGlow"></div>
  <div class="ice-crack-overlay" id="iceCrackOverlay"></div>
  <div class="particles-container" id="particlesContainer"></div>

  <!-- Audio elements for sound effects -->
  <audio id="iceCrackSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
  </audio>

  <!-- Auto-reset countdown -->
  <div class="countdown-overlay" id="countdownOverlay">
    <div class="countdown-label">RESETTING IN</div>
    <div class="countdown-number" id="countdownNumber">10</div>
    <div class="countdown-bar" id="countdownBar">
      <div class="countdown-bar-fill" id="countdownBarFill"></div>
    </div>
  </div>

  <!-- Milestone Achievement Popup -->
  <div class="milestone-popup" id="milestonePopup">
    <div class="milestone-icon" id="milestoneIcon"></div>
    <div class="milestone-title" id="milestoneTitle">DOUBLE SPEED!</div>
    <div class="milestone-subtitle" id="milestoneSubtitle">First time hitting 2x</div>
  </div>

  <!-- Ludicrous Speed Effects -->
  <div class="ludicrous-overlay" id="ludicrousOverlay"></div>
  <div class="speed-lines" id="speedLines"></div>

  <!-- Session Stats -->
  <div class="session-stats" id="sessionStats">
    <div class="stat-line">
      <span class="stat-icon"></span>
      <span>Changes: <span class="stat-value" id="statChanges">0</span></span>
    </div>
    <div class="stat-line">
      <span class="stat-icon"></span>
      <span>Speed ups: <span class="stat-value" id="statSpeedUps">0</span></span>
    </div>
    <div class="stat-line">
      <span class="stat-icon"></span>
      <span>Slow downs: <span class="stat-value" id="statSlowDowns">0</span></span>
    </div>
    <div class="stat-line">
      <span class="stat-icon"></span>
      <span>Peak: <span class="stat-value stat-highlight" id="statPeak">1.00x</span></span>
    </div>
  </div>

  <!-- Combo Display -->
  <div class="combo-display" id="comboDisplay">
    <div class="combo-count" id="comboCount">5x</div>
    <div class="combo-label" id="comboLabel">COMBO</div>
    <div class="combo-bonus" id="comboBonus">+0.1x BOOST!</div>
  </div>

  <!-- Combo Popup -->
  <div class="combo-popup" id="comboPopup"> 5x COMBO!</div>

  <!-- Leaderboard -->
  <div class="leaderboard" id="leaderboard">
    <div class="leaderboard-title"> TOP CONTRIBUTORS</div>
    <div id="leaderboardEntries">
      <!-- Entries will be added dynamically -->
    </div>
  </div>

  <!-- PixiJS for ridiculous effects -->
  <canvas id="pixiCanvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:100;"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@7/dist/pixi.min.js"></script>

  <script src="main.js"></script>
  <script>
    const STORAGE_KEY = 'hyd_gamehud_settings';

    // ============ PIXI.JS RIDICULOUS EFFECTS SYSTEM ============
    let pixiApp = null;
    let pixiEffects = null;

    async function initPixiEffects() {
      if (typeof PIXI === 'undefined') {
        console.warn('PixiJS not loaded, skipping effects');
        return;
      }

      const canvas = document.getElementById('pixiCanvas');

      pixiApp = new PIXI.Application();
      await pixiApp.init({
        canvas: canvas,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundAlpha: 0,
        antialias: true,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true,
      });

      // Containers for different effect layers
      const containers = {
        background: new PIXI.Container(),
        particles: new PIXI.Container(),
        lightning: new PIXI.Container(),
        explosions: new PIXI.Container(),
        glitch: new PIXI.Container()
      };

      Object.values(containers).forEach(c => pixiApp.stage.addChild(c));

      // Particle pools
      const sparkPool = [];
      const emberPool = [];
      const snowPool = [];

      // ============ LIGHTNING BOLT EFFECT ============
      class LightningBolt {
        constructor(startX, startY, endX, endY) {
          this.graphics = new PIXI.Graphics();
          this.life = 1;
          this.segments = [];
          this.generateSegments(startX, startY, endX, endY);
          containers.lightning.addChild(this.graphics);
        }

        generateSegments(x1, y1, x2, y2, depth = 0) {
          if (depth > 5) {
            this.segments.push({ x1, y1, x2, y2, width: Math.max(1, 6 - depth) });
            return;
          }

          const midX = (x1 + x2) / 2 + (Math.random() - 0.5) * 80 / (depth + 1);
          const midY = (y1 + y2) / 2 + (Math.random() - 0.5) * 80 / (depth + 1);

          this.generateSegments(x1, y1, midX, midY, depth + 1);
          this.generateSegments(midX, midY, x2, y2, depth + 1);

          // Random branches
          if (Math.random() < 0.3 && depth < 3) {
            const branchAngle = Math.atan2(y2 - y1, x2 - x1) + (Math.random() - 0.5) * Math.PI / 2;
            const branchLen = 50 + Math.random() * 100;
            const branchEndX = midX + Math.cos(branchAngle) * branchLen;
            const branchEndY = midY + Math.sin(branchAngle) * branchLen;
            this.generateSegments(midX, midY, branchEndX, branchEndY, depth + 2);
          }
        }

        draw() {
          this.graphics.clear();

          // Outer glow
          this.graphics.setStrokeStyle({ width: 12, color: 0x4444ff, alpha: this.life * 0.3 });
          this.segments.forEach(seg => {
            this.graphics.moveTo(seg.x1, seg.y1);
            this.graphics.lineTo(seg.x2, seg.y2);
          });
          this.graphics.stroke();

          // Middle glow
          this.graphics.setStrokeStyle({ width: 6, color: 0x8888ff, alpha: this.life * 0.6 });
          this.segments.forEach(seg => {
            this.graphics.moveTo(seg.x1, seg.y1);
            this.graphics.lineTo(seg.x2, seg.y2);
          });
          this.graphics.stroke();

          // Core
          this.graphics.setStrokeStyle({ width: 2, color: 0xffffff, alpha: this.life });
          this.segments.forEach(seg => {
            this.graphics.moveTo(seg.x1, seg.y1);
            this.graphics.lineTo(seg.x2, seg.y2);
          });
          this.graphics.stroke();
        }

        update(delta) {
          this.life -= 0.05 * delta;
          this.draw();
          return this.life > 0;
        }

        destroy() {
          containers.lightning.removeChild(this.graphics);
          this.graphics.destroy();
        }
      }

      // ============ SPARK PARTICLE ============
      class Spark {
        constructor() {
          this.graphics = new PIXI.Graphics();
          this.active = false;
          containers.particles.addChild(this.graphics);
        }

        spawn(x, y, color, vx, vy) {
          this.x = x;
          this.y = y;
          this.vx = vx || (Math.random() - 0.5) * 15;
          this.vy = vy || -Math.random() * 10 - 5;
          this.life = 1;
          this.size = 2 + Math.random() * 4;
          this.color = color || 0xffaa00;
          this.active = true;
          this.gravity = 0.3;
          this.trail = [];
        }

        update(delta) {
          if (!this.active) return false;

          this.trail.push({ x: this.x, y: this.y, life: 0.5 });
          if (this.trail.length > 8) this.trail.shift();

          this.vy += this.gravity * delta;
          this.x += this.vx * delta;
          this.y += this.vy * delta;
          this.life -= 0.02 * delta;

          this.trail.forEach(t => t.life -= 0.1 * delta);

          this.graphics.clear();

          // Trail
          this.trail.forEach((t, i) => {
            if (t.life > 0) {
              this.graphics.circle(t.x, t.y, this.size * t.life * 0.5);
              this.graphics.fill({ color: this.color, alpha: t.life * this.life * 0.5 });
            }
          });

          // Main spark
          this.graphics.circle(this.x, this.y, this.size * this.life);
          this.graphics.fill({ color: this.color, alpha: this.life });

          // Core glow
          this.graphics.circle(this.x, this.y, this.size * this.life * 0.5);
          this.graphics.fill({ color: 0xffffff, alpha: this.life * 0.8 });

          if (this.life <= 0 || this.y > window.innerHeight + 50) {
            this.active = false;
            this.graphics.clear();
          }

          return this.active;
        }
      }

      // ============ EXPLOSION EFFECT ============
      class Explosion {
        constructor(x, y, color, count = 50) {
          this.sparks = [];
          for (let i = 0; i < count; i++) {
            let spark = sparkPool.find(s => !s.active);
            if (!spark) {
              spark = new Spark();
              sparkPool.push(spark);
            }
            const angle = (Math.PI * 2 * i / count) + (Math.random() - 0.5) * 0.5;
            const speed = 5 + Math.random() * 15;
            spark.spawn(x, y, color, Math.cos(angle) * speed, Math.sin(angle) * speed);
            spark.gravity = 0.1;
            this.sparks.push(spark);
          }

          // Shockwave
          this.ring = new PIXI.Graphics();
          this.ringRadius = 0;
          this.ringMaxRadius = 200;
          this.ringLife = 1;
          this.color = color;
          containers.explosions.addChild(this.ring);
          this.x = x;
          this.y = y;
        }

        update(delta) {
          this.ringRadius += 15 * delta;
          this.ringLife -= 0.03 * delta;

          this.ring.clear();
          if (this.ringLife > 0) {
            this.ring.circle(this.x, this.y, this.ringRadius);
            this.ring.stroke({ width: 4 + this.ringLife * 8, color: this.color, alpha: this.ringLife * 0.8 });

            // Inner ring
            this.ring.circle(this.x, this.y, this.ringRadius * 0.7);
            this.ring.stroke({ width: 2, color: 0xffffff, alpha: this.ringLife * 0.5 });
          }

          const active = this.sparks.some(s => s.active) || this.ringLife > 0;
          if (!active) {
            containers.explosions.removeChild(this.ring);
            this.ring.destroy();
          }
          return active;
        }
      }

      // ============ ELECTRIC ARC ============
      class ElectricArc {
        constructor() {
          this.graphics = new PIXI.Graphics();
          this.points = [];
          this.life = 0;
          containers.lightning.addChild(this.graphics);
        }

        spawn(x1, y1, x2, y2) {
          this.life = 1;
          this.x1 = x1; this.y1 = y1;
          this.x2 = x2; this.y2 = y2;
        }

        update(delta) {
          if (this.life <= 0) return false;

          this.graphics.clear();
          this.life -= 0.08 * delta;

          // Generate jagged line
          const segments = 20;
          let lastX = this.x1, lastY = this.y1;

          // Outer glow
          this.graphics.moveTo(this.x1, this.y1);
          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const x = this.x1 + (this.x2 - this.x1) * t + (Math.random() - 0.5) * 30 * (1 - t);
            const y = this.y1 + (this.y2 - this.y1) * t + (Math.random() - 0.5) * 30;
            this.graphics.lineTo(x, y);
          }
          this.graphics.stroke({ width: 8, color: 0x00aaff, alpha: this.life * 0.3 });

          // Core
          this.graphics.moveTo(this.x1, this.y1);
          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const x = this.x1 + (this.x2 - this.x1) * t + (Math.random() - 0.5) * 20;
            const y = this.y1 + (this.y2 - this.y1) * t + (Math.random() - 0.5) * 20;
            this.graphics.lineTo(x, y);
          }
          this.graphics.stroke({ width: 2, color: 0xffffff, alpha: this.life });

          return this.life > 0;
        }
      }

      // ============ CHROMATIC ABERRATION / GLITCH ============
      let glitchIntensity = 0;
      let glitchTimer = 0;
      const glitchBars = [];

      class GlitchBar {
        constructor() {
          this.graphics = new PIXI.Graphics();
          this.active = false;
          containers.glitch.addChild(this.graphics);
        }

        spawn() {
          this.y = Math.random() * window.innerHeight;
          this.height = 2 + Math.random() * 20;
          this.offset = (Math.random() - 0.5) * 50;
          this.life = 0.1 + Math.random() * 0.2;
          this.active = true;
        }

        update(delta) {
          if (!this.active) return false;
          this.life -= 0.1 * delta;

          this.graphics.clear();
          if (this.life > 0) {
            // RGB split effect bars
            this.graphics.rect(0, this.y, window.innerWidth, this.height);
            this.graphics.fill({ color: Math.random() > 0.5 ? 0xff0000 : 0x00ffff, alpha: 0.3 * this.life });
          } else {
            this.active = false;
          }
          return this.active;
        }
      }

      // ============ AMBIENT SPARKS ============
      class AmbientSpark {
        constructor() {
          this.graphics = new PIXI.Graphics();
          this.active = false;
          containers.background.addChild(this.graphics);
        }

        spawn(type) {
          this.x = Math.random() * window.innerWidth;
          this.y = type === 'fire' ? window.innerHeight + 10 : -10;
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = type === 'fire' ? -(1 + Math.random() * 3) : (1 + Math.random() * 2);
          this.size = 1 + Math.random() * 3;
          this.life = 1;
          this.type = type;
          this.wobble = Math.random() * Math.PI * 2;
          this.active = true;
        }

        update(delta) {
          if (!this.active) return false;

          this.wobble += 0.1 * delta;
          this.x += (this.vx + Math.sin(this.wobble) * 0.5) * delta;
          this.y += this.vy * delta;
          this.life -= 0.005 * delta;

          this.graphics.clear();

          if (this.type === 'fire') {
            // Ember
            this.graphics.circle(this.x, this.y, this.size);
            this.graphics.fill({ color: 0xff4400, alpha: this.life * 0.8 });
            this.graphics.circle(this.x, this.y, this.size * 0.5);
            this.graphics.fill({ color: 0xffff00, alpha: this.life });
          } else {
            // Ice crystal
            this.graphics.circle(this.x, this.y, this.size);
            this.graphics.fill({ color: 0x88ddff, alpha: this.life * 0.6 });
          }

          if (this.life <= 0 ||
              (this.type === 'fire' && this.y < -50) ||
              (this.type === 'ice' && this.y > window.innerHeight + 50)) {
            this.active = false;
            this.graphics.clear();
          }

          return this.active;
        }
      }

      // Pools for ambient sparks
      const ambientSparkPool = [];
      for (let i = 0; i < 100; i++) {
        ambientSparkPool.push(new AmbientSpark());
      }

      // Glitch bars pool
      for (let i = 0; i < 20; i++) {
        glitchBars.push(new GlitchBar());
      }

      // Active effects tracking
      const activeLightning = [];
      const activeExplosions = [];
      const activeArcs = [];
      let ambientMode = 'none';
      let ambientIntensity = 0;

      // ============ MAIN UPDATE LOOP ============
      pixiApp.ticker.add((ticker) => {
        const delta = ticker.deltaTime;

        // Update lightning
        for (let i = activeLightning.length - 1; i >= 0; i--) {
          if (!activeLightning[i].update(delta)) {
            activeLightning[i].destroy();
            activeLightning.splice(i, 1);
          }
        }

        // Update explosions
        for (let i = activeExplosions.length - 1; i >= 0; i--) {
          if (!activeExplosions[i].update(delta)) {
            activeExplosions.splice(i, 1);
          }
        }

        // Update sparks
        sparkPool.forEach(s => s.active && s.update(delta));

        // Update arcs
        for (let i = activeArcs.length - 1; i >= 0; i--) {
          if (!activeArcs[i].update(delta)) {
            activeArcs.splice(i, 1);
          }
        }

        // Update glitch
        if (glitchIntensity > 0) {
          glitchTimer += delta;
          if (glitchTimer > 2) {
            const bar = glitchBars.find(b => !b.active);
            if (bar) bar.spawn();
            glitchTimer = 0;
          }
          glitchIntensity -= 0.01 * delta;
        }
        glitchBars.forEach(b => b.update(delta));

        // Ambient particles
        if (ambientMode !== 'none' && ambientIntensity > 0) {
          if (Math.random() < ambientIntensity * 0.1) {
            const spark = ambientSparkPool.find(s => !s.active);
            if (spark) spark.spawn(ambientMode);
          }
        }
        ambientSparkPool.forEach(s => s.active && s.update(delta));
      });

      // ============ PUBLIC API ============
      pixiEffects = {
        lightning: (fromX, fromY, toX, toY) => {
          const bolt = new LightningBolt(
            fromX ?? Math.random() * window.innerWidth,
            fromY ?? 0,
            toX ?? Math.random() * window.innerWidth,
            toY ?? window.innerHeight
          );
          activeLightning.push(bolt);
        },

        lightningStorm: (count = 5) => {
          for (let i = 0; i < count; i++) {
            setTimeout(() => {
              pixiEffects.lightning();
            }, i * 100);
          }
        },

        explosion: (x, y, color = 0xff4400, count = 50) => {
          const exp = new Explosion(
            x ?? window.innerWidth / 2,
            y ?? window.innerHeight / 2,
            color,
            count
          );
          activeExplosions.push(exp);
        },

        sparks: (x, y, color, count = 20) => {
          for (let i = 0; i < count; i++) {
            let spark = sparkPool.find(s => !s.active);
            if (!spark) {
              spark = new Spark();
              sparkPool.push(spark);
            }
            spark.spawn(x, y, color);
          }
        },

        electricArc: (x1, y1, x2, y2) => {
          let arc = activeArcs.find(a => a.life <= 0);
          if (!arc) {
            arc = new ElectricArc();
            activeArcs.push(arc);
          }
          arc.spawn(x1, y1, x2, y2);
        },

        glitch: (intensity = 1, duration = 500) => {
          glitchIntensity = intensity;
          setTimeout(() => { glitchIntensity = 0; }, duration);
        },

        setAmbient: (mode, intensity = 0.5) => {
          ambientMode = mode; // 'fire', 'ice', or 'none'
          ambientIntensity = intensity;
        },

        chaos: () => {
          // Ultimate chaos effect!
          pixiEffects.lightningStorm(8);
          pixiEffects.glitch(1, 1000);

          // Multiple explosions
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              pixiEffects.explosion(
                Math.random() * window.innerWidth,
                Math.random() * window.innerHeight,
                [0xff0000, 0x00ff00, 0x0000ff, 0xff00ff, 0xffff00][i % 5],
                30
              );
            }, i * 150);
          }

          // Electric arcs across screen
          for (let i = 0; i < 10; i++) {
            setTimeout(() => {
              pixiEffects.electricArc(
                Math.random() * window.innerWidth,
                Math.random() * window.innerHeight,
                Math.random() * window.innerWidth,
                Math.random() * window.innerHeight
              );
            }, i * 50);
          }
        },

        speedUp: () => {
          pixiEffects.explosion(window.innerWidth / 2, window.innerHeight - 100, 0xff4400, 40);
          pixiEffects.sparks(window.innerWidth / 2, window.innerHeight - 50, 0xff8800, 30);
        },

        slowDown: () => {
          pixiEffects.explosion(window.innerWidth / 2, 100, 0x88ddff, 40);
          pixiEffects.sparks(window.innerWidth / 2, 50, 0xaaeeff, 30);
        },

        reset: () => {
          pixiEffects.explosion(window.innerWidth / 2, window.innerHeight / 2, 0x00ff88, 60);
          pixiEffects.lightningStorm(3);
        }
      };

      // Handle resize
      window.addEventListener('resize', () => {
        pixiApp.renderer.resize(window.innerWidth, window.innerHeight);
      });

      console.log(' PixiJS Effects System initialized!');
    }

    // Initialize PixiJS when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPixiEffects);
    } else {
      initPixiEffects();
    }

    // Default avatar SVG (properly encoded for use in src attribute)
    const DEFAULT_AVATAR = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="#333"/><circle cx="50" cy="40" r="20" fill="#666"/><ellipse cx="50" cy="85" rx="35" ry="25" fill="#666"/></svg>');

    // Handle avatar loading errors
    function handleAvatarError(img) {
      img.onerror = null; // Prevent infinite loop
      img.src = DEFAULT_AVATAR;
    }

    const defaults = {
      transparent: false,
      scanlines: true,
      showBpm: true,
      showTempo: true,
      showTimeSig: true,
      showGauge: true,
      showBar: true,
      showBeat: true,
      showFeed: true,
      screenShake: true,
      flash: true,
      particles: true,
      thresholdEffects: true,
      fireThreshold: 1.3,
      iceThreshold: 0.8,
      botUrl: 'ws://localhost:9030'
    };

    function loadSettings() {
      const urlParams = new URLSearchParams(window.location.search);
      const stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');

      return {
        transparent: urlParams.has('transparent') ? urlParams.get('transparent') === 'true' : (stored.transparent ?? defaults.transparent),
        scanlines: urlParams.has('scanlines') ? urlParams.get('scanlines') !== 'false' : (stored.scanlines ?? defaults.scanlines),
        showBpm: urlParams.has('bpm') ? urlParams.get('bpm') !== 'false' : (stored.showBpm ?? defaults.showBpm),
        showTempo: urlParams.has('tempo') ? urlParams.get('tempo') !== 'false' : (stored.showTempo ?? defaults.showTempo),
        showTimeSig: urlParams.has('timesig') ? urlParams.get('timesig') !== 'false' : (stored.showTimeSig ?? defaults.showTimeSig),
        showGauge: urlParams.has('gauge') ? urlParams.get('gauge') !== 'false' : (stored.showGauge ?? defaults.showGauge),
        showBar: urlParams.has('bar') ? urlParams.get('bar') !== 'false' : (stored.showBar ?? defaults.showBar),
        showBeat: urlParams.has('beat') ? urlParams.get('beat') !== 'false' : (stored.showBeat ?? defaults.showBeat),
        showFeed: urlParams.has('feed') ? urlParams.get('feed') !== 'false' : (stored.showFeed ?? defaults.showFeed),
        screenShake: urlParams.has('shake') ? urlParams.get('shake') !== 'false' : (stored.screenShake ?? defaults.screenShake),
        flash: urlParams.has('flash') ? urlParams.get('flash') !== 'false' : (stored.flash ?? defaults.flash),
        particles: urlParams.has('particles') ? urlParams.get('particles') !== 'false' : (stored.particles ?? defaults.particles),
        thresholdEffects: urlParams.has('threshold') ? urlParams.get('threshold') !== 'false' : (stored.thresholdEffects ?? defaults.thresholdEffects),
        fireThreshold: parseFloat(urlParams.get('fire')) || stored.fireThreshold || defaults.fireThreshold,
        iceThreshold: parseFloat(urlParams.get('ice')) || stored.iceThreshold || defaults.iceThreshold,
        botUrl: urlParams.get('bot') || stored.botUrl || defaults.botUrl,
        hideSettings: urlParams.get('hideSettings') === 'true'
      };
    }

    let settings = loadSettings();

    // Elements
    const hudContainer = document.getElementById('hudContainer');
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsToggle = document.getElementById('settingsToggle');
    const bpmSection = document.getElementById('bpmSection');
    const tempoSection = document.getElementById('tempoSection');
    const tempoValue = document.getElementById('tempoValue');
    const timeSigSection = document.getElementById('timeSigSection');
    const gaugeSection = document.getElementById('gaugeSection');
    const barSection = document.getElementById('barSection');
    const beatSection = document.getElementById('beatSection');
    const feedSection = document.getElementById('feedSection');
    const bpmValue = document.getElementById('bpmValue');
    const timeSigValue = document.getElementById('timeSigValue');
    const playrateValue = document.getElementById('playrateValue');
    const gaugeFill = document.getElementById('gaugeFill');
    const gaugeNeedle = document.getElementById('gaugeNeedle');
    const playrateMarker = document.getElementById('playrateMarker');
    const beatRing = document.getElementById('beatRing');
    const beatNumber = document.getElementById('beatNumber');
    const beatDots = document.getElementById('beatDots');
    const changeFeed = document.getElementById('changeFeed');
    const fireOverlay = document.getElementById('fireOverlay');
    const iceOverlay = document.getElementById('iceOverlay');
    const flashOverlay = document.getElementById('flashOverlay');
    const particlesContainer = document.getElementById('particlesContainer');
    const slowIndicator = document.getElementById('slowIndicator');
    const fastIndicator = document.getElementById('fastIndicator');

    // Inputs
    const inputs = {
      transparent: document.getElementById('setTransparent'),
      scanlines: document.getElementById('setScanlines'),
      showBpm: document.getElementById('setShowBpm'),
      showTempo: document.getElementById('setShowTempo'),
      showTimeSig: document.getElementById('setShowTimeSig'),
      showGauge: document.getElementById('setShowGauge'),
      showBar: document.getElementById('setShowBar'),
      showBeat: document.getElementById('setShowBeat'),
      showFeed: document.getElementById('setShowFeed'),
      screenShake: document.getElementById('setScreenShake'),
      flash: document.getElementById('setFlash'),
      particles: document.getElementById('setParticles'),
      thresholdEffects: document.getElementById('setThresholdEffects'),
      fireThreshold: document.getElementById('setFireThreshold'),
      iceThreshold: document.getElementById('setIceThreshold')
    };

    function applySettings() {
      document.body.classList.toggle('transparent-bg', settings.transparent);
      document.body.classList.toggle('no-scanlines', !settings.scanlines);

      bpmSection.style.display = settings.showBpm ? '' : 'none';
      tempoSection.style.display = settings.showTempo ? '' : 'none';
      timeSigSection.style.display = settings.showTimeSig ? '' : 'none';
      gaugeSection.style.display = settings.showGauge ? '' : 'none';
      barSection.style.display = settings.showBar ? '' : 'none';
      beatSection.style.display = settings.showBeat ? '' : 'none';
      feedSection.style.display = settings.showFeed ? '' : 'none';

      if (settings.hideSettings) {
        settingsToggle.classList.add('hidden');
        settingsPanel.classList.add('hidden');
      }

      // Update inputs
      inputs.transparent.checked = settings.transparent;
      inputs.scanlines.checked = settings.scanlines;
      inputs.showBpm.checked = settings.showBpm;
      inputs.showTempo.checked = settings.showTempo;
      inputs.showTimeSig.checked = settings.showTimeSig;
      inputs.showGauge.checked = settings.showGauge;
      inputs.showBar.checked = settings.showBar;
      inputs.showBeat.checked = settings.showBeat;
      inputs.showFeed.checked = settings.showFeed;
      inputs.screenShake.checked = settings.screenShake;
      inputs.flash.checked = settings.flash;
      inputs.particles.checked = settings.particles;
      inputs.thresholdEffects.checked = settings.thresholdEffects;
      inputs.fireThreshold.value = settings.fireThreshold;
      inputs.iceThreshold.value = settings.iceThreshold;

      document.getElementById('fireThresholdVal').textContent = settings.fireThreshold;
      document.getElementById('iceThresholdVal').textContent = settings.iceThreshold;
    }

    function readSettings() {
      settings.transparent = inputs.transparent.checked;
      settings.scanlines = inputs.scanlines.checked;
      settings.showBpm = inputs.showBpm.checked;
      settings.showTempo = inputs.showTempo.checked;
      settings.showTimeSig = inputs.showTimeSig.checked;
      settings.showGauge = inputs.showGauge.checked;
      settings.showBar = inputs.showBar.checked;
      settings.showBeat = inputs.showBeat.checked;
      settings.showFeed = inputs.showFeed.checked;
      settings.screenShake = inputs.screenShake.checked;
      settings.flash = inputs.flash.checked;
      settings.particles = inputs.particles.checked;
      settings.thresholdEffects = inputs.thresholdEffects.checked;
      settings.fireThreshold = parseFloat(inputs.fireThreshold.value);
      settings.iceThreshold = parseFloat(inputs.iceThreshold.value);
    }

    function generateUrl() {
      const base = window.location.origin + window.location.pathname;
      const p = new URLSearchParams();
      p.set('transparent', settings.transparent);
      p.set('scanlines', settings.scanlines);
      p.set('bpm', settings.showBpm);
      p.set('tempo', settings.showTempo);
      p.set('timesig', settings.showTimeSig);
      p.set('gauge', settings.showGauge);
      p.set('bar', settings.showBar);
      p.set('beat', settings.showBeat);
      p.set('feed', settings.showFeed);
      p.set('shake', settings.screenShake);
      p.set('flash', settings.flash);
      p.set('particles', settings.particles);
      p.set('threshold', settings.thresholdEffects);
      p.set('fire', settings.fireThreshold);
      p.set('ice', settings.iceThreshold);
      p.set('hideSettings', 'true');
      document.getElementById('generatedUrl').value = base + '?' + p.toString();
    }

    // Event listeners
    Object.values(inputs).forEach(input => {
      input.addEventListener('change', () => { readSettings(); applySettings(); generateUrl(); });
      input.addEventListener('input', () => { readSettings(); applySettings(); generateUrl(); });
    });

    settingsToggle.addEventListener('click', () => settingsPanel.classList.toggle('open'));

    document.getElementById('saveSettings').addEventListener('click', () => {
      readSettings();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      alert('Settings saved!');
    });

    document.getElementById('resetSettings').addEventListener('click', () => {
      if (confirm('Reset all settings?')) {
        localStorage.removeItem(STORAGE_KEY);
        settings = { ...defaults };
        applySettings();
        generateUrl();
      }
    });

    document.getElementById('copyUrl').addEventListener('click', () => {
      const url = document.getElementById('generatedUrl');
      url.select();
      navigator.clipboard.writeText(url.value).then(() => {
        const msg = document.getElementById('copiedMsg');
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), 2000);
      });
    });

    applySettings();
    generateUrl();

    // ============ GAME STATE ============
    let currentPlayrate = 1.0;
    let lastPlayrate = 1.0;
    let currentBpm = 120;
    let currentTimeSig = '4/4';
    let currentBeat = 1;
    let timeSigNum = 4;
    let changeHistory = [];

    // Generate beat dots
    function generateBeatDots(beats) {
      beatDots.innerHTML = '';
      for (let i = 1; i <= beats; i++) {
        const dot = document.createElement('div');
        dot.className = 'beat-dot' + (i === 1 ? ' downbeat-dot' : '');
        dot.id = 'dot-' + i;
        beatDots.appendChild(dot);
      }
    }
    generateBeatDots(4);

    // ============ EFFECTS ============
    function triggerShake() {
      if (!settings.screenShake) return;
      hudContainer.classList.remove('shake');
      void hudContainer.offsetWidth; // Reflow
      hudContainer.classList.add('shake');
    }

    function triggerFlash() {
      if (!settings.flash) return;
      flashOverlay.classList.remove('flash');
      void flashOverlay.offsetWidth;
      flashOverlay.classList.add('flash');
    }

    // Burst particle pool
    const burstPool = [];
    const BURST_POOL_SIZE = 40;
    for (let i = 0; i < BURST_POOL_SIZE; i++) {
      const p = document.createElement('div');
      p.className = 'particle';
      p.style.display = 'none';
      particlesContainer.appendChild(p);
      burstPool.push(p);
    }

    function spawnParticles(type, count = 15) {
      if (!settings.particles) return;

      // Use DocumentFragment for batch insert if pool exhausted
      const isFireType = type === 'fire';

      for (let i = 0; i < count; i++) {
        const p = burstPool.find(p => p.style.display === 'none');
        if (!p) continue;

        const size = 10 + Math.random() * 20;
        const dur = 0.4 + Math.random() * 0.4;

        p.className = 'particle ' + type;
        p.style.cssText = `
          display:block;
          width:${size}px;
          height:${size}px;
          left:${Math.random() * 100}%;
          ${isFireType ? 'bottom:0' : 'top:0'};
          animation:particle${isFireType ? 'Fire' : 'Ice'} ${dur}s ease-out forwards;
          animation-delay:${Math.random() * 0.3}s;
        `;

        setTimeout(() => { p.style.display = 'none'; }, (dur + 0.3) * 1000);
      }
    }

    function updateThresholdEffects(playrate) {
      if (!settings.thresholdEffects) {
        fireOverlay.classList.remove('active');
        iceOverlay.classList.remove('active');
        return;
      }

      if (playrate >= settings.fireThreshold) {
        fireOverlay.classList.add('active');
        iceOverlay.classList.remove('active');
        fastIndicator.classList.add('active');
        slowIndicator.classList.remove('active');
      } else if (playrate <= settings.iceThreshold) {
        iceOverlay.classList.add('active');
        fireOverlay.classList.remove('active');
        slowIndicator.classList.add('active');
        fastIndicator.classList.remove('active');
      } else {
        fireOverlay.classList.remove('active');
        iceOverlay.classList.remove('active');
        fastIndicator.classList.remove('active');
        slowIndicator.classList.remove('active');
      }
    }

    // ============ DOOM FIRE SIMULATION (60FPS Canvas) ============
    const fireCanvas = document.getElementById('fireCanvas');
    const fireCtx = fireCanvas.getContext('2d');

    // Fire simulation config
    const FIRE_WIDTH = 160;  // Low res for performance + retro look
    const FIRE_HEIGHT = 50;
    const PIXEL_SIZE = 4;

    // Fire color palette (black -> red -> orange -> yellow -> white)
    const FIRE_PALETTE = [
      [0, 0, 0, 0],         // 0: transparent
      [7, 7, 7, 255],       // 1: near black
      [31, 7, 7, 255],      // 2: dark red
      [47, 15, 7, 255],     // 3
      [71, 15, 7, 255],     // 4
      [87, 23, 7, 255],     // 5
      [103, 31, 7, 255],    // 6
      [119, 31, 7, 255],    // 7
      [143, 39, 7, 255],    // 8
      [159, 47, 7, 255],    // 9
      [175, 63, 7, 255],    // 10
      [191, 71, 7, 255],    // 11
      [199, 71, 7, 255],    // 12
      [223, 79, 7, 255],    // 13
      [223, 87, 7, 255],    // 14
      [223, 87, 7, 255],    // 15
      [215, 95, 7, 255],    // 16
      [215, 95, 7, 255],    // 17
      [215, 103, 15, 255],  // 18
      [207, 111, 15, 255],  // 19
      [207, 119, 15, 255],  // 20
      [207, 127, 15, 255],  // 21
      [207, 135, 23, 255],  // 22
      [199, 135, 23, 255],  // 23
      [199, 143, 23, 255],  // 24
      [199, 151, 31, 255],  // 25
      [191, 159, 31, 255],  // 26
      [191, 159, 31, 255],  // 27
      [191, 167, 39, 255],  // 28
      [191, 167, 39, 255],  // 29
      [191, 175, 47, 255],  // 30
      [183, 175, 47, 255],  // 31
      [183, 183, 47, 255],  // 32
      [183, 183, 55, 255],  // 33
      [207, 207, 111, 255], // 34
      [223, 223, 159, 255], // 35
      [239, 239, 199, 255], // 36
      [255, 255, 255, 255]  // 37: white (hottest)
    ];

    // Fire state
    let firePixels = new Uint8Array(FIRE_WIDTH * FIRE_HEIGHT);
    let fireImageData = null;
    let fireRAF = null;
    let fireIntensity = 0;
    let fireRunning = false;

    // Initialize canvas
    function initFireCanvas() {
      fireCanvas.width = FIRE_WIDTH;
      fireCanvas.height = FIRE_HEIGHT;
      fireImageData = fireCtx.createImageData(FIRE_WIDTH, FIRE_HEIGHT);

      // Initialize bottom row with max heat
      for (let x = 0; x < FIRE_WIDTH; x++) {
        firePixels[(FIRE_HEIGHT - 1) * FIRE_WIDTH + x] = FIRE_PALETTE.length - 1;
      }
    }
    initFireCanvas();

    // Elements to apply fire text effects to
    const fireTextElements = [
      playrateValue,
      tempoValue,
      document.querySelector('.bpm-value'),
      document.querySelector('.beat-number')
    ].filter(Boolean);

    function updateFireTextEffects(intensity) {
      const intensityClass =
        intensity >= 0.85 ? 'intensity-max' :
        intensity >= 0.6 ? 'intensity-high' :
        intensity >= 0.3 ? 'intensity-medium' :
        intensity > 0 ? 'intensity-low' : '';

      fireTextElements.forEach(el => {
        // Remove ice classes first
        el.classList.remove('ice-text-effect', 'intensity-low', 'intensity-medium', 'intensity-high', 'intensity-max');

        if (intensityClass) {
          el.classList.add('fire-text-effect', intensityClass);
        } else {
          el.classList.remove('fire-text-effect');
        }
      });
    }

    function startAmbientFire(intensity) {
      fireIntensity = intensity;
      fireCanvas.classList.add('active');

      // Scale canvas height based on intensity (150px to 400px)
      const minHeight = 150;
      const maxHeight = 400;
      const height = minHeight + intensity * (maxHeight - minHeight);
      fireCanvas.style.height = height + 'px';

      // Apply text effects
      updateFireTextEffects(intensity);

      if (!fireRunning && settings.particles) {
        fireRunning = true;
        fireRAF = requestAnimationFrame(fireLoop);
      }
    }

    function stopAmbientFire() {
      fireIntensity = 0;
      fireCanvas.classList.remove('active');
      fireRunning = false;
      if (fireRAF) {
        cancelAnimationFrame(fireRAF);
        fireRAF = null;
      }
      // Cool down the fire
      firePixels.fill(0);
    }

    function fireLoop() {
      if (!fireRunning) return;

      updateFire();
      renderFire();

      fireRAF = requestAnimationFrame(fireLoop);
    }

    function updateFire() {
      const maxColor = FIRE_PALETTE.length - 1;

      // Intensity affects fuel amount, decay rate, and spread
      // At low intensity (0.1): less fuel, more decay = small flames
      // At high intensity (1.0): max fuel, less decay = towering inferno
      const fuelBase = 0.3 + fireIntensity * 0.7;  // 0.3 to 1.0
      const fuel = Math.floor(maxColor * fuelBase);
      const decayRate = 3.5 - fireIntensity * 2.0;  // 3.5 to 1.5 (less decay at high intensity)
      const spreadChance = 0.3 + fireIntensity * 0.4;  // 0.3 to 0.7

      // Update bottom row (fuel source) with randomness
      for (let x = 0; x < FIRE_WIDTH; x++) {
        // More consistent fuel at higher intensity
        const fuelVariation = 1 - fireIntensity * 0.5;  // Less variation at high intensity
        firePixels[(FIRE_HEIGHT - 1) * FIRE_WIDTH + x] =
          Math.floor(Math.random() * fuel * fuelVariation) + Math.floor(fuel * (1 - fuelVariation));
      }

      // Propagate fire upward
      for (let y = 0; y < FIRE_HEIGHT - 1; y++) {
        for (let x = 0; x < FIRE_WIDTH; x++) {
          const srcIdx = (y + 1) * FIRE_WIDTH + x;
          const pixel = firePixels[srcIdx];

          if (pixel === 0) {
            firePixels[y * FIRE_WIDTH + x] = 0;
          } else {
            // Decay scales with intensity - less decay = taller flames
            const decay = Math.floor(Math.random() * decayRate);

            // Horizontal drift - more spread at higher intensity
            const driftRange = Math.random() < spreadChance ? 2 : 1;
            const drift = Math.floor(Math.random() * (driftRange * 2 + 1)) - driftRange;
            const dstX = Math.min(FIRE_WIDTH - 1, Math.max(0, x + drift));
            const dstIdx = y * FIRE_WIDTH + dstX;

            firePixels[dstIdx] = Math.max(0, pixel - decay);
          }
        }
      }
    }

    function renderFire() {
      const data = fireImageData.data;

      for (let y = 0; y < FIRE_HEIGHT; y++) {
        for (let x = 0; x < FIRE_WIDTH; x++) {
          const fireIdx = y * FIRE_WIDTH + x;
          const colorIdx = firePixels[fireIdx];
          const color = FIRE_PALETTE[colorIdx] || FIRE_PALETTE[0];

          const pixelIdx = fireIdx * 4;
          data[pixelIdx] = color[0];
          data[pixelIdx + 1] = color[1];
          data[pixelIdx + 2] = color[2];
          data[pixelIdx + 3] = color[3];
        }
      }

      fireCtx.putImageData(fireImageData, 0, 0);
    }

    // ============ SNOWFALL/SNOWSTORM SIMULATION (60FPS Canvas) ============
    const iceCanvas = document.getElementById('iceCanvas');
    const iceCtx = iceCanvas.getContext('2d');
    const iceGlow = document.getElementById('iceGlow');
    const iceCrackOverlay = document.getElementById('iceCrackOverlay');
    const iceCrackSound = document.getElementById('iceCrackSound');

    // Snowfall configuration
    const MAX_SNOWFLAKES = 500;  // Maximum particles for heavy snowstorm
    const snowflakes = [];

    // Snow state
    let iceRAF = null;
    let iceIntensity = 0;
    let iceRunning = false;
    let snowFading = false;  // Gradual fade out transition
    let fadeProgress = 0;
    let windOffset = 0;      // For wind animation
    let lastIceCrackTime = 0;

    // Snowflake class
    class Snowflake {
      constructor(canvasWidth, canvasHeight, intensity) {
        this.reset(canvasWidth, canvasHeight, intensity, true);
      }

      reset(canvasWidth, canvasHeight, intensity, randomY = false) {
        this.x = Math.random() * canvasWidth;
        this.y = randomY ? Math.random() * canvasHeight : -10;
        this.size = 1 + Math.random() * 4 + intensity * 2;  // 1-7px based on intensity
        this.speed = 1 + Math.random() * 2 + intensity * 3;  // Fall speed
        this.wobbleSpeed = 0.5 + Math.random() * 1.5;
        this.wobbleAmount = 10 + Math.random() * 20 + intensity * 30;  // Side-to-side
        this.wobbleOffset = Math.random() * Math.PI * 2;
        this.opacity = 0.4 + Math.random() * 0.6;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;

        // Snowflake type: 0 = circle, 1 = star, 2 = detailed
        this.type = this.size > 4 ? (Math.random() < 0.3 ? 2 : 1) : 0;
      }

      update(canvasWidth, canvasHeight, intensity, deltaTime, wind) {
        // Fall down
        this.y += this.speed * deltaTime * 60;

        // Wobble side to side + wind
        const wobble = Math.sin(this.y * 0.01 * this.wobbleSpeed + this.wobbleOffset) * this.wobbleAmount * 0.1;
        this.x += wobble + wind * deltaTime * 60;

        // Rotate
        this.rotation += this.rotationSpeed;

        // Reset if off screen
        if (this.y > canvasHeight + 10 || this.x < -50 || this.x > canvasWidth + 50) {
          this.reset(canvasWidth, canvasHeight, intensity);
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.opacity;

        if (this.type === 0) {
          // Simple circle snowflake
          ctx.beginPath();
          ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
          ctx.fillStyle = 'white';
          ctx.fill();
        } else if (this.type === 1) {
          // Star snowflake
          this.drawStar(ctx, this.size / 2);
        } else {
          // Detailed snowflake
          this.drawDetailedSnowflake(ctx, this.size / 2);
        }

        ctx.restore();
      }

      drawStar(ctx, radius) {
        ctx.beginPath();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.stroke();
      }

      drawDetailedSnowflake(ctx, radius) {
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          ctx.save();
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(radius, 0);
          // Branch
          ctx.moveTo(radius * 0.5, 0);
          ctx.lineTo(radius * 0.7, -radius * 0.3);
          ctx.moveTo(radius * 0.5, 0);
          ctx.lineTo(radius * 0.7, radius * 0.3);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    // Initialize snow canvas
    function initSnowCanvas() {
      resizeSnowCanvas();
      window.addEventListener('resize', resizeSnowCanvas);
    }

    function resizeSnowCanvas() {
      iceCanvas.width = window.innerWidth;
      iceCanvas.height = window.innerHeight;
    }
    initSnowCanvas();

    // ============ SNOW ACCUMULATION ON TEXT ============
    // Track snow piles on text elements
    const snowPiles = new Map();  // elementId -> { particles: [], maxHeight: number }
    const textElementIds = ['playrateValue', 'bpmValue', 'tempoValue', 'timeSigValue'];
    let snowAccumulationRate = 0;
    let maxSnowHeight = 25;  // Maximum snow pile height in pixels

    class SnowPileParticle {
      constructor(x, baseY, size) {
        this.x = x;
        this.y = baseY;
        this.size = size * (0.8 + Math.random() * 0.4);  // Vary size slightly
        this.opacity = 0.85 + Math.random() * 0.15;
        this.settled = false;
        this.settleSpeed = 0.5 + Math.random() * 0.5;
        this.targetY = baseY;
      }

      update(deltaTime, pileHeight) {
        // Settle down to rest on top of existing pile
        this.targetY = this.y - pileHeight;
        if (!this.settled) {
          const dy = (this.targetY - this.y) * 0.1;
          this.y += dy;
          if (Math.abs(this.y - this.targetY) < 0.5) {
            this.settled = true;
          }
        }
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.fill();
      }
    }

    function getTextElementBounds() {
      const bounds = [];
      for (const id of textElementIds) {
        const el = document.getElementById(id);
        if (el && el.offsetParent !== null) {  // Check if visible
          const rect = el.getBoundingClientRect();
          bounds.push({
            id: id,
            left: rect.left,
            right: rect.right,
            top: rect.top,
            bottom: rect.bottom,
            width: rect.width,
            height: rect.height
          });
        }
      }
      return bounds;
    }

    function accumulateSnowOnText(deltaTime) {
      if (iceIntensity <= 0 || snowFading) return;

      const bounds = getTextElementBounds();
      const accumRate = iceIntensity * 2 * deltaTime;  // More snow at higher intensity

      for (const bound of bounds) {
        if (!snowPiles.has(bound.id)) {
          snowPiles.set(bound.id, { particles: [], height: 0 });
        }

        const pile = snowPiles.get(bound.id);

        // Add new snow particles based on intensity and time
        if (Math.random() < accumRate) {
          // Random x position along the top of the text
          const x = bound.left + Math.random() * bound.width;
          const y = bound.top - 2;  // Just above the text
          const size = 2 + Math.random() * 3;

          // Only add if pile isn't too high
          if (pile.height < maxSnowHeight) {
            pile.particles.push(new SnowPileParticle(x, y, size));
            pile.height = Math.min(maxSnowHeight, pile.height + size * 0.3);
          }
        }

        // Update existing particles
        for (const particle of pile.particles) {
          particle.update(deltaTime, pile.height);
        }
      }
    }

    function renderSnowPiles() {
      for (const [id, pile] of snowPiles) {
        for (const particle of pile.particles) {
          particle.draw(iceCtx);
        }
      }
    }

    function clearSnowPiles() {
      for (const [id, pile] of snowPiles) {
        pile.particles = [];
        pile.height = 0;
      }
    }

    function meltSnowPiles(deltaTime) {
      for (const [id, pile] of snowPiles) {
        if (pile.particles.length > 0) {
          // Remove particles gradually (melting)
          const meltRate = Math.ceil(pile.particles.length * 0.05 * deltaTime * 60);
          for (let i = 0; i < meltRate && pile.particles.length > 0; i++) {
            pile.particles.pop();
          }
          pile.height = Math.max(0, pile.height - deltaTime * 10);
        }
      }
    }

    // Ice text effects - similar structure to fire but for cold
    function updateIceTextEffects(intensity) {
      const intensityClass =
        intensity >= 0.85 ? 'intensity-max' :
        intensity >= 0.6 ? 'intensity-high' :
        intensity >= 0.3 ? 'intensity-medium' :
        intensity > 0 ? 'intensity-low' : '';

      fireTextElements.forEach(el => {
        // Remove fire classes first
        el.classList.remove('fire-text-effect', 'intensity-low', 'intensity-medium', 'intensity-high', 'intensity-max');

        if (intensityClass) {
          el.classList.add('ice-text-effect', intensityClass);
        } else {
          el.classList.remove('ice-text-effect');
        }
      });
    }

    function clearTextEffects() {
      fireTextElements.forEach(el => {
        el.classList.remove('fire-text-effect', 'ice-text-effect', 'intensity-low', 'intensity-medium', 'intensity-high', 'intensity-max');
      });
    }

    // Play wind/blizzard sound
    function playWindSound() {
      const now = Date.now();
      if (now - lastIceCrackTime < 3000) return;
      lastIceCrackTime = now;

      if (iceCrackSound && iceCrackSound.src && !iceCrackSound.src.includes('AAAA')) {
        iceCrackSound.currentTime = 0;
        iceCrackSound.volume = 0.2 * iceIntensity;
        iceCrackSound.play().catch(() => {});
      }
    }

    let lastSnowTime = performance.now();

    function startAmbientIce(intensity) {
      const prevIntensity = iceIntensity;
      iceIntensity = intensity;
      snowFading = false;
      fadeProgress = 0;

      iceCanvas.classList.add('active');
      iceCanvas.style.opacity = '';
      iceGlow.classList.add('active');

      // Target number of snowflakes based on intensity
      // Light snow: 50, Heavy blizzard: 500
      const targetCount = Math.floor(50 + intensity * 450);

      // Add snowflakes if needed
      while (snowflakes.length < targetCount) {
        snowflakes.push(new Snowflake(iceCanvas.width, iceCanvas.height, intensity));
      }

      // Remove excess snowflakes
      while (snowflakes.length > targetCount) {
        snowflakes.pop();
      }

      // Show blizzard overlay at high intensity
      if (intensity >= 0.7) {
        iceCrackOverlay.classList.add('active');
        iceCrackOverlay.style.background = `
          linear-gradient(to bottom, rgba(200, 230, 255, ${0.1 + intensity * 0.15}) 0%, transparent 30%),
          linear-gradient(to top, rgba(200, 230, 255, ${0.05 + intensity * 0.1}) 0%, transparent 20%)
        `;
      } else {
        iceCrackOverlay.classList.remove('active');
      }

      // Apply ice text effects
      updateIceTextEffects(intensity);

      // Occasional wind sound at high intensity
      if (intensity >= 0.8 && Math.random() < 0.005) {
        playWindSound();
      }

      if (!iceRunning && settings.particles) {
        iceRunning = true;
        lastSnowTime = performance.now();
        iceRAF = requestAnimationFrame(snowLoop);
      }
    }

    function stopAmbientIce() {
      // Start fade out instead of stopping immediately
      if (iceRunning && !snowFading && snowflakes.length > 0) {
        snowFading = true;
        fadeProgress = 0;
        iceGlow.classList.remove('active');
        iceCrackOverlay.classList.remove('active');
        clearTextEffects();
        return;
      }

      forceStopAmbientIce();
    }

    function forceStopAmbientIce() {
      iceIntensity = 0;
      snowFading = false;
      fadeProgress = 0;

      iceCanvas.style.opacity = '';
      iceCanvas.classList.remove('active');
      iceGlow.classList.remove('active');
      iceCrackOverlay.classList.remove('active');
      iceRunning = false;

      if (iceRAF) {
        cancelAnimationFrame(iceRAF);
        iceRAF = null;
      }

      // Clear all snowflakes
      snowflakes.length = 0;

      // Clear snow piles on text
      clearSnowPiles();

      // Clear canvas
      iceCtx.clearRect(0, 0, iceCanvas.width, iceCanvas.height);

      clearTextEffects();
    }

    function snowLoop() {
      if (!iceRunning) return;

      const now = performance.now();
      const deltaTime = Math.min((now - lastSnowTime) / 1000, 0.1);  // Cap at 100ms
      lastSnowTime = now;

      updateSnow(deltaTime);
      renderSnow();

      // Handle fading
      if (snowFading) {
        fadeProgress += deltaTime * 0.5;  // ~2 seconds to fade
        iceCanvas.style.opacity = Math.max(0, 1 - fadeProgress);

        // Gradually remove snowflakes
        const removeCount = Math.ceil(snowflakes.length * deltaTime * 0.5);
        for (let i = 0; i < removeCount && snowflakes.length > 0; i++) {
          snowflakes.pop();
        }

        // Melt snow piles gradually
        meltSnowPiles(deltaTime);

        // Check if everything is cleared
        let allPilesMelted = true;
        for (const [id, pile] of snowPiles) {
          if (pile.particles.length > 0) {
            allPilesMelted = false;
            break;
          }
        }

        if (fadeProgress >= 1 && snowflakes.length === 0 && allPilesMelted) {
          forceStopAmbientIce();
          return;
        }
      }

      iceRAF = requestAnimationFrame(snowLoop);
    }

    function updateSnow(deltaTime) {
      // Calculate wind based on intensity (stronger wind = more horizontal movement)
      // Oscillating wind for natural effect
      windOffset += deltaTime * (1 + iceIntensity * 2);
      const baseWind = Math.sin(windOffset * 0.5) * iceIntensity * 2;  // -2 to +2
      const gustWind = Math.sin(windOffset * 2.3) * iceIntensity * 1.5;  // Gusts
      const wind = baseWind + gustWind;

      // Update all snowflakes
      for (const flake of snowflakes) {
        flake.update(iceCanvas.width, iceCanvas.height, iceIntensity, deltaTime, wind);
      }

      // Accumulate snow on text elements
      accumulateSnowOnText(deltaTime);
    }

    function renderSnow() {
      // Clear canvas
      iceCtx.clearRect(0, 0, iceCanvas.width, iceCanvas.height);

      // Optional: Add slight blur/fog at high intensity
      if (iceIntensity >= 0.6) {
        const fogOpacity = (iceIntensity - 0.6) * 0.15;  // 0 to 0.06
        iceCtx.fillStyle = `rgba(200, 220, 255, ${fogOpacity})`;
        iceCtx.fillRect(0, 0, iceCanvas.width, iceCanvas.height);
      }

      // Draw all snowflakes
      for (const flake of snowflakes) {
        flake.draw(iceCtx);
      }

      // Draw snow piles on text
      renderSnowPiles();
    }

    function updateAmbientEffects(playrate) {
      // Fire zone: playrate >= fire threshold
      if (playrate >= settings.fireThreshold) {
        // Force stop ice immediately (fire evaporates it instantly)
        forceStopAmbientIce();

        // Calculate fire intensity proportional to playrate
        // Fire threshold (e.g. 1.3x) = intensity 0.1 (small flames)
        // 2.0x = intensity ~0.4 (medium flames)
        // 3.0x = intensity ~0.7 (large flames)
        // 4.0x = intensity 1.0 (maximum inferno)
        const minRate = settings.fireThreshold;
        const maxRate = 4.0;  // Max playrate supported

        // Non-linear scaling - fire grows faster at higher speeds
        const normalized = (playrate - minRate) / (maxRate - minRate);
        const intensity = Math.min(1, 0.1 + Math.pow(normalized, 0.7) * 0.9);

        startAmbientFire(intensity);

        // PixiJS ambient fire embers
        if (pixiEffects) pixiEffects.setAmbient('fire', intensity);
      }
      // Ice zone: playrate <= ice threshold
      else if (playrate <= settings.iceThreshold) {
        // Stop fire if it was running
        stopAmbientFire();

        // Calculate ice intensity proportional to how slow
        // Ice threshold (e.g. 0.8x) = intensity 0.1 (light frost)
        // 0.6x = intensity ~0.5 (medium ice)
        // 0.5x = intensity 1.0 (maximum freeze)
        const maxRate = settings.iceThreshold;
        const minRate = 0.25;  // Min playrate supported

        // Non-linear scaling - ice grows faster at lower speeds
        const normalized = (maxRate - playrate) / (maxRate - minRate);
        const intensity = Math.min(1, 0.1 + Math.pow(normalized, 0.7) * 0.9);

        startAmbientIce(intensity);

        // PixiJS ambient ice crystals
        if (pixiEffects) pixiEffects.setAmbient('ice', intensity);
      }
      // Normal zone: no effects
      else {
        stopAmbientFire();
        stopAmbientIce();

        // Stop PixiJS ambient effects
        if (pixiEffects) pixiEffects.setAmbient('none', 0);
      }
    }

    // ============ MILESTONES & ACHIEVEMENTS ============
    const milestonePopup = document.getElementById('milestonePopup');
    const milestoneIcon = document.getElementById('milestoneIcon');
    const milestoneTitle = document.getElementById('milestoneTitle');
    const milestoneSubtitle = document.getElementById('milestoneSubtitle');
    const ludicrousOverlay = document.getElementById('ludicrousOverlay');
    const speedLinesContainer = document.getElementById('speedLines');
    const sessionStatsEl = document.getElementById('sessionStats');

    // Session tracking
    const sessionStats = {
      changes: 0,
      speedUps: 0,
      slowDowns: 0,
      peakSpeed: 1.0,
      lowestSpeed: 1.0,
      milestonesHit: new Set(),  // Track which milestones achieved this session
      ludicrousActive: false,
      frozenActive: false,
      // Combo tracking
      currentCombo: 0,
      comboType: null,  // 'speedUp' or 'slowDown'
      maxCombo: 0,
      lastActionTime: 0,
      comboTimeout: null
    };

    // Leaderboard tracking
    const leaderboard = new Map();  // username -> { contributions: number, combos: number, maxCombo: number }

    // Combo elements
    const comboDisplay = document.getElementById('comboDisplay');
    const comboCount = document.getElementById('comboCount');
    const comboLabel = document.getElementById('comboLabel');
    const comboBonus = document.getElementById('comboBonus');
    const comboPopup = document.getElementById('comboPopup');
    const leaderboardEl = document.getElementById('leaderboard');
    const leaderboardEntries = document.getElementById('leaderboardEntries');

    // Combo thresholds for bonuses
    const comboMilestones = [3, 5, 7, 10, 15, 20, 25];
    const comboTimeout = 8000;  // Combo breaks after 8 seconds of inactivity

    function updateCombo(direction, username) {
      const now = Date.now();
      const timeSinceLastAction = now - sessionStats.lastActionTime;

      // Check if combo should reset (different direction or timeout)
      if (sessionStats.comboType !== direction || timeSinceLastAction > comboTimeout) {
        sessionStats.currentCombo = 0;
        sessionStats.comboType = direction;
      }

      // Increment combo
      sessionStats.currentCombo++;
      sessionStats.lastActionTime = now;

      // Track max combo
      if (sessionStats.currentCombo > sessionStats.maxCombo) {
        sessionStats.maxCombo = sessionStats.currentCombo;
      }

      // Update leaderboard
      if (username) {
        updateLeaderboard(username, sessionStats.currentCombo);
      }

      // Clear existing timeout
      if (sessionStats.comboTimeout) {
        clearTimeout(sessionStats.comboTimeout);
      }

      // Set new timeout to reset combo
      sessionStats.comboTimeout = setTimeout(() => {
        resetCombo();
      }, comboTimeout);

      // Update display
      updateComboDisplay();

      // Check for combo milestones
      if (comboMilestones.includes(sessionStats.currentCombo)) {
        showComboMilestone(sessionStats.currentCombo, direction);
      }
    }

    function updateComboDisplay() {
      const combo = sessionStats.currentCombo;

      if (combo < 2) {
        comboDisplay.classList.remove('active');
        return;
      }

      comboDisplay.classList.add('active');
      comboCount.textContent = combo + 'x';

      // Update label based on type
      const isFast = sessionStats.comboType === 'speedUp';
      comboLabel.textContent = isFast ? ' COMBO' : ' COMBO';

      // Update intensity class
      comboDisplay.classList.remove('combo-hot', 'combo-fire', 'combo-blazing', 'combo-legendary',
                                     'combo-ice', 'combo-frozen', 'combo-glacial');

      if (isFast) {
        if (combo >= 15) comboDisplay.classList.add('combo-legendary');
        else if (combo >= 10) comboDisplay.classList.add('combo-blazing');
        else if (combo >= 5) comboDisplay.classList.add('combo-fire');
        else comboDisplay.classList.add('combo-hot');
      } else {
        if (combo >= 10) comboDisplay.classList.add('combo-glacial');
        else if (combo >= 5) comboDisplay.classList.add('combo-frozen');
        else comboDisplay.classList.add('combo-ice');
      }

      // Show bonus at milestones
      if (comboMilestones.includes(combo)) {
        const bonusAmount = Math.floor(combo / 5) * 0.1;
        if (bonusAmount > 0) {
          comboBonus.textContent = `+${bonusAmount.toFixed(1)}x BOOST!`;
          comboBonus.classList.add('show');
          setTimeout(() => comboBonus.classList.remove('show'), 2000);
        }
      }
    }

    function showComboMilestone(combo, direction) {
      const isFast = direction === 'speedUp';
      const emoji = isFast ? '' : '';

      comboPopup.textContent = `${emoji} ${combo}x COMBO!`;
      comboPopup.className = 'combo-popup ' + (isFast ? 'fire' : 'ice');

      // Trigger animation
      comboPopup.classList.remove('active');
      void comboPopup.offsetWidth;
      comboPopup.classList.add('active');

      // Spawn particles
      spawnCelebrationParticles(isFast ? 'fast' : 'slow');

      // Screen shake for big combos
      if (combo >= 5) {
        triggerShake();
      }

      setTimeout(() => {
        comboPopup.classList.remove('active');
      }, 1500);
    }

    function resetCombo() {
      sessionStats.currentCombo = 0;
      sessionStats.comboType = null;
      comboDisplay.classList.remove('active');
    }

    function updateLeaderboard(username, combo) {
      if (!username) return;

      if (!leaderboard.has(username)) {
        leaderboard.set(username, { contributions: 0, combos: 0, maxCombo: 0 });
      }

      const entry = leaderboard.get(username);
      entry.contributions++;
      if (combo >= 3) entry.combos++;
      if (combo > entry.maxCombo) entry.maxCombo = combo;

      renderLeaderboard();
    }

    function renderLeaderboard() {
      // Sort by contributions
      const sorted = [...leaderboard.entries()]
        .sort((a, b) => b[1].contributions - a[1].contributions)
        .slice(0, 5);  // Top 5

      if (sorted.length === 0) {
        leaderboardEl.classList.remove('visible');
        return;
      }

      leaderboardEl.classList.add('visible');

      leaderboardEntries.innerHTML = sorted.map(([name, data], index) => {
        const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
        const rankIcon = index === 0 ? '' : index === 1 ? '' : index === 2 ? '' : (index + 1);
        return `
          <div class="leaderboard-entry">
            <span class="leaderboard-rank ${rankClass}">${rankIcon}</span>
            <span class="leaderboard-name">${escapeHtml(name)}</span>
            <span class="leaderboard-score">${data.contributions}</span>
          </div>
        `;
      }).join('');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Milestone definitions
    const milestones = {
      // Fast milestones
      'speed-2x': { threshold: 2.0, icon: '', title: 'DOUBLE SPEED!', subtitle: 'First time hitting 2x!' },
      'speed-3x': { threshold: 3.0, icon: '', title: 'TRIPLE THREAT!', subtitle: 'First time hitting 3x!' },
      'speed-4x': { threshold: 4.0, icon: '', title: 'MAXIMUM OVERDRIVE!', subtitle: 'First time hitting 4x!' },
      'ludicrous': { threshold: 3.5, icon: '', title: 'LUDICROUS SPEED!', subtitle: "They've gone to plaid!" },
      // Slow milestones
      'slow-half': { threshold: 0.5, icon: '', title: 'HALF SPEED!', subtitle: 'Taking it easy at 0.5x' },
      'slow-quarter': { threshold: 0.25, icon: '', title: 'SLOTH MODE!', subtitle: 'Crawling at 0.25x!' },
      'frozen': { threshold: 0.3, icon: '', title: 'FROZEN SOLID!', subtitle: 'Time nearly stands still...' }
    };

    const celebrationEmojis = {
      fast: ['', '', '', '', '', '', '', '', '', ''],
      slow: ['', '', '', '', '', '', '', '', '', '']
    };

    function showMilestone(milestoneKey) {
      if (sessionStats.milestonesHit.has(milestoneKey)) return;  // Already shown this session
      sessionStats.milestonesHit.add(milestoneKey);

      const milestone = milestones[milestoneKey];
      if (!milestone) return;

      // Update popup content
      milestoneIcon.textContent = milestone.icon;
      milestoneTitle.textContent = milestone.title;
      milestoneSubtitle.textContent = milestone.subtitle;

      // Set style class
      milestonePopup.className = 'milestone-popup ' + milestoneKey;

      // Trigger animation
      milestonePopup.classList.remove('active');
      void milestonePopup.offsetWidth;  // Force reflow
      milestonePopup.classList.add('active');

      // Spawn celebration particles (use slow emojis for slow milestones)
      const isSlow = milestoneKey.startsWith('slow') || milestoneKey === 'frozen';
      spawnCelebrationParticles(isSlow ? 'slow' : 'fast');

      // Screen shake
      triggerShake();

      // Flash effect
      triggerFlash();

      // Remove active class after animation
      setTimeout(() => {
        milestonePopup.classList.remove('active');
      }, 2500);
    }

    function spawnCelebrationParticles(type = 'fast') {
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const particleCount = 20;
      const emojis = celebrationEmojis[type] || celebrationEmojis.fast;

      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'celebration-particle';
        particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];

        // Random direction
        const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
        const distance = 150 + Math.random() * 200;
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance - 100;  // Bias upward
        const rot = (Math.random() - 0.5) * 720;

        particle.style.left = centerX + 'px';
        particle.style.top = centerY + 'px';
        particle.style.setProperty('--tx', tx + 'px');
        particle.style.setProperty('--ty', ty + 'px');
        particle.style.setProperty('--rot', rot + 'deg');

        document.body.appendChild(particle);

        // Clean up after animation
        setTimeout(() => particle.remove(), 1500);
      }
    }

    function updateLudicrousMode(playrate) {
      const isLudicrous = playrate >= 3.5;

      if (isLudicrous && !sessionStats.ludicrousActive) {
        // Entering ludicrous mode
        sessionStats.ludicrousActive = true;
        ludicrousOverlay.classList.add('active');
        speedLinesContainer.classList.add('active');
        createSpeedLines();

        // Show milestone if first time
        if (!sessionStats.milestonesHit.has('ludicrous')) {
          showMilestone('ludicrous');
        }
      } else if (!isLudicrous && sessionStats.ludicrousActive) {
        // Exiting ludicrous mode
        sessionStats.ludicrousActive = false;
        ludicrousOverlay.classList.remove('active');
        speedLinesContainer.classList.remove('active');
        clearSpeedLines();
      }
    }

    function createSpeedLines() {
      clearSpeedLines();
      const lineCount = 15;

      for (let i = 0; i < lineCount; i++) {
        const line = document.createElement('div');
        line.className = 'speed-line';
        line.style.top = (Math.random() * 100) + '%';
        line.style.width = (50 + Math.random() * 100) + 'px';
        line.style.animationDelay = (Math.random() * 0.3) + 's';
        line.style.animationDuration = (0.2 + Math.random() * 0.2) + 's';
        speedLinesContainer.appendChild(line);
      }
    }

    function clearSpeedLines() {
      speedLinesContainer.innerHTML = '';
    }

    function checkMilestones(playrate) {
      // Check FAST milestones (only trigger on first time hitting each)
      if (playrate >= 4.0 && !sessionStats.milestonesHit.has('speed-4x')) {
        showMilestone('speed-4x');
      } else if (playrate >= 3.0 && playrate < 4.0 && !sessionStats.milestonesHit.has('speed-3x')) {
        showMilestone('speed-3x');
      } else if (playrate >= 2.0 && playrate < 3.0 && !sessionStats.milestonesHit.has('speed-2x')) {
        showMilestone('speed-2x');
      }

      // Check SLOW milestones
      if (playrate <= 0.25 && !sessionStats.milestonesHit.has('slow-quarter')) {
        showMilestone('slow-quarter');
      } else if (playrate <= 0.3 && playrate > 0.25 && !sessionStats.milestonesHit.has('frozen')) {
        showMilestone('frozen');
      } else if (playrate <= 0.5 && playrate > 0.3 && !sessionStats.milestonesHit.has('slow-half')) {
        showMilestone('slow-half');
      }

      // Update ludicrous mode (fast) and frozen mode (slow)
      updateLudicrousMode(playrate);
      updateFrozenMode(playrate);
    }

    function updateFrozenMode(playrate) {
      const isFrozen = playrate <= 0.3;

      if (isFrozen && !sessionStats.frozenActive) {
        sessionStats.frozenActive = true;
        // Could add frozen screen effects here
      } else if (!isFrozen && sessionStats.frozenActive) {
        sessionStats.frozenActive = false;
      }
    }

    function updateSessionStats(oldRate, newRate, username = null) {
      if (Math.abs(newRate - oldRate) < 0.01) return;  // Ignore tiny changes

      sessionStats.changes++;

      const isSpeedUp = newRate > oldRate;
      if (isSpeedUp) {
        sessionStats.speedUps++;
      } else {
        sessionStats.slowDowns++;
      }

      if (newRate > sessionStats.peakSpeed) {
        sessionStats.peakSpeed = newRate;
      }
      if (newRate < sessionStats.lowestSpeed) {
        sessionStats.lowestSpeed = newRate;
      }

      // Update combo system
      updateCombo(isSpeedUp ? 'speedUp' : 'slowDown', username);

      // Update display
      document.getElementById('statChanges').textContent = sessionStats.changes;
      document.getElementById('statSpeedUps').textContent = sessionStats.speedUps;
      document.getElementById('statSlowDowns').textContent = sessionStats.slowDowns;
      document.getElementById('statPeak').textContent = sessionStats.peakSpeed.toFixed(2) + 'x';

      // Show stats after first change
      if (sessionStats.changes === 1) {
        sessionStatsEl.classList.add('visible');
      }
    }

    // ============ AUTO-RESET COUNTDOWN ============
    const countdownOverlay = document.getElementById('countdownOverlay');
    const countdownNumber = document.getElementById('countdownNumber');
    const countdownBar = document.getElementById('countdownBar');
    const countdownBarFill = document.getElementById('countdownBarFill');

    let countdownTimer = null;
    let countdownEndTime = 0;
    let autoResetEnabled = false; // Will be updated from bot config
    let autoResetDelay = 60; // Will be updated from bot config
    let showCountdownAt = 10; // Show countdown when this many seconds remain

    function startCountdown(delaySeconds) {
      cancelCountdown();
      autoResetDelay = delaySeconds;
      countdownEndTime = Date.now() + (delaySeconds * 1000);
      countdownTimer = setInterval(updateCountdown, 100);
    }

    function cancelCountdown() {
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
      countdownOverlay.classList.remove('active');
      countdownNumber.classList.remove('urgent');
      countdownBar.classList.remove('urgent');
    }

    function updateCountdown() {
      const remaining = Math.max(0, countdownEndTime - Date.now()) / 1000;

      if (remaining <= 0) {
        cancelCountdown();
        // Reset happened - flash effect
        triggerFlash();
        triggerShake();
        return;
      }

      // Only show countdown in final seconds
      if (remaining <= showCountdownAt) {
        countdownOverlay.classList.add('active');

        const displaySeconds = Math.ceil(remaining);
        countdownNumber.textContent = displaySeconds;

        // Progress bar
        const progress = (remaining / showCountdownAt) * 100;
        countdownBarFill.style.width = progress + '%';

        // Urgent mode in final 3 seconds
        if (remaining <= 3) {
          countdownNumber.classList.add('urgent');
          countdownBar.classList.add('urgent');
        } else {
          countdownNumber.classList.remove('urgent');
          countdownBar.classList.remove('urgent');
        }
      } else {
        countdownOverlay.classList.remove('active');
      }
    }

    function addToFeed(oldRate, newRate, username, action, avatarUrl) {
      const diff = newRate - oldRate;
      if (Math.abs(diff) < 0.01 && !username) return;

      const item = document.createElement('div');
      item.className = 'feed-item ' + (diff > 0 ? 'speed-up' : 'slow-down');

      const direction = diff > 0 ? '+' : '';
      const actionIcons = {
        speedUp: '',
        slowDown: '',
        chaos: '',
        reset: ''
      };
      const icon = actionIcons[action] || (diff > 0 ? '' : '');
      const displayName = username || 'Unknown';

      // Use provided avatar or default
      const avatar = avatarUrl || DEFAULT_AVATAR;

      // Create elements properly to avoid inline handler issues
      const avatarImg = document.createElement('img');
      avatarImg.className = 'user-avatar';
      avatarImg.src = avatar;
      avatarImg.alt = displayName;
      avatarImg.onerror = function() { handleAvatarError(this); };

      const feedContent = document.createElement('div');
      feedContent.className = 'feed-content';
      feedContent.innerHTML = `
        <div class="change-header">
          <span class="change-amount">${icon} ${direction}${(diff * 100).toFixed(0)}%</span>
        </div>
        <div class="change-user">${displayName}</div>
        <div class="change-rate">${newRate.toFixed(2)}x</div>
        <div class="change-time">${new Date().toLocaleTimeString()}</div>
      `;

      item.appendChild(avatarImg);
      item.appendChild(feedContent);
      changeFeed.insertBefore(item, changeFeed.firstChild);

      // Keep only last 4
      while (changeFeed.children.length > 4) {
        changeFeed.removeChild(changeFeed.lastChild);
      }

      // Auto-hide after 4 seconds
      setTimeout(() => {
        if (item.parentNode) {
          item.classList.add('slide-out');
          // Remove from DOM after animation completes
          setTimeout(() => {
            if (item.parentNode) {
              item.remove();
            }
          }, 500);
        }
      }, 4000);
    }

    // ============ GAUGE UPDATE ============
    function updateGauge(playrate) {
      // Map playrate (0.5 - 2.0) to angle (-90 to 90 degrees)
      const minRate = 0.5, maxRate = 2.0;
      const clampedRate = Math.max(minRate, Math.min(maxRate, playrate));
      const normalized = (clampedRate - minRate) / (maxRate - minRate);
      const angle = -90 + (normalized * 180);

      gaugeNeedle.style.transform = `rotate(${angle}deg)`;

      // Color based on zone
      let color;
      if (playrate >= settings.fireThreshold) {
        color = 'var(--fire-orange)';
      } else if (playrate <= settings.iceThreshold) {
        color = 'var(--ice-blue)';
      } else if (playrate > 1.1) {
        color = 'var(--neon-yellow)';
      } else if (playrate < 0.9) {
        color = 'var(--neon-blue)';
      } else {
        color = 'var(--neon-green)';
      }

      gaugeFill.style.stroke = color;

      // Arc fill amount
      const arcLength = 455;
      const fillAmount = arcLength * (1 - normalized);
      gaugeFill.style.strokeDashoffset = fillAmount;
    }

    function updatePlayrateBar(playrate) {
      // Map 0.5-2.0 to 0-100%
      const minRate = 0.5, maxRate = 2.0;
      const normalized = (playrate - minRate) / (maxRate - minRate);
      const percent = Math.max(0, Math.min(100, normalized * 100));
      playrateMarker.style.left = percent + '%';
    }

    function updatePlayrateDisplay(playrate) {
      playrateValue.textContent = playrate.toFixed(2) + 'x';

      let color;
      if (playrate >= settings.fireThreshold) {
        color = 'var(--fire-orange)';
      } else if (playrate <= settings.iceThreshold) {
        color = 'var(--ice-blue)';
      } else {
        color = 'var(--neon-green)';
      }
      playrateValue.style.color = color;
    }

    // ============ BEAT UPDATE ============
    function updateBeat(beat, isDownbeat) {
      beatNumber.textContent = beat;

      beatRing.classList.remove('pulse', 'downbeat');
      void beatRing.offsetWidth;

      if (isDownbeat) {
        beatRing.classList.add('downbeat');
      } else {
        beatRing.classList.add('pulse');
      }

      // Update dots
      const dots = beatDots.querySelectorAll('.beat-dot');
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i < beat);
      });
    }

    // ============ REAPER COMMUNICATION ============
    wwr_start();
    wwr_req_recur("GET/PROJEXTSTATE/Teleprompter/data;TRANSPORT", 16);

    let lastBeat = 0;

    function wwr_onreply(results) {
      for (const line of results.split("\n")) {
        const tok = line.split("\t");
        if (tok.length > 3 && tok[1] === "Teleprompter" && tok[2] === "data") {
          try {
            const d = JSON.parse(tok[3] || '{}');

            const newPlayrate = d.pr || 1;
            const newBpm = d.bpm || 120;
            const newTimeSig = d.ts || '4/4';
            const newBeat = d.b || 1;

            // Playrate change detection
            if (Math.abs(newPlayrate - lastPlayrate) > 0.01) {
              // Check if this change was already handled by bot WebSocket
              const recentBotAction = pendingAction && (Date.now() - pendingAction.time < 2000);
              const matchesBotAction = recentBotAction && Math.abs(newPlayrate - pendingAction.newRate) < 0.02;

              if (!matchesBotAction) {
                // This is a manual change or bot isn't connected - show effects without username
                const wasSpeedUp = newPlayrate > lastPlayrate;

                triggerShake();
                triggerFlash();

                if (wasSpeedUp) {
                  spawnParticles('fire', 30);
                  playrateValue.classList.remove('slow-down');
                  playrateValue.classList.add('speed-up');
                } else {
                  spawnParticles('ice', 30);
                  playrateValue.classList.remove('speed-up');
                  playrateValue.classList.add('slow-down');
                }

                setTimeout(() => {
                  playrateValue.classList.remove('speed-up', 'slow-down');
                }, 300);

                addToFeed(lastPlayrate, newPlayrate, null, null);

                // Update session stats and check milestones
                updateSessionStats(lastPlayrate, newPlayrate);
                checkMilestones(newPlayrate);
              }

              lastPlayrate = newPlayrate;
              pendingAction = null; // Clear after handling
            }

            currentPlayrate = newPlayrate;
            currentBpm = newBpm;
            currentBeat = newBeat;

            // Time sig change
            if (newTimeSig !== currentTimeSig) {
              currentTimeSig = newTimeSig;
              timeSigNum = parseInt(newTimeSig.split('/')[0]) || 4;
              generateBeatDots(timeSigNum);
            }

            // Beat change
            if (newBeat !== lastBeat) {
              updateBeat(newBeat, newBeat === 1);
              lastBeat = newBeat;
            }

          } catch (e) {}
        }
      }

      updateDisplay();
    }

    function updateDisplay() {
      bpmValue.textContent = Math.round(currentBpm);
      timeSigValue.textContent = currentTimeSig;

      // Calculate and display effective tempo (BPM * playrate)
      const calculatedTempo = Math.round(currentBpm * currentPlayrate);
      tempoValue.textContent = calculatedTempo;

      // Color the tempo based on playrate
      tempoValue.classList.remove('fast', 'slow');
      if (currentPlayrate >= settings.fireThreshold) {
        tempoValue.classList.add('fast');
      } else if (currentPlayrate <= settings.iceThreshold) {
        tempoValue.classList.add('slow');
      }

      updatePlayrateDisplay(currentPlayrate);
      updateGauge(currentPlayrate);
      updatePlayrateBar(currentPlayrate);
      updateThresholdEffects(currentPlayrate);
      updateAmbientEffects(currentPlayrate);
    }

    // Initial display
    updateDisplay();

    // ============ BOT WEBSOCKET CONNECTION ============
    let botWs = null;
    let lastSentBpm = 0;
    let pendingAction = null; // Store action info to match with playrate change

    function connectToBot() {
      if (!settings.botUrl) return;

      try {
        botWs = new WebSocket(settings.botUrl);

        botWs.onopen = () => {
          console.log('Connected to Playrate Bot');
          // Send current BPM immediately
          if (currentBpm > 0) {
            sendBpmToBot(currentBpm);
          }
        };

        botWs.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            console.log('Bot message received:', msg.type, msg);

            // Handle action events from bot (with username!)
            if (msg.type === 'actionProcessed' && msg.data) {
              const { action, username, newRate, avatarUrl } = msg.data;
              const oldRate = lastPlayrate;

              // Trigger effects
              triggerShake();
              triggerFlash();

              if (newRate > oldRate) {
                spawnParticles('fire', 30);
                playrateValue.classList.add('speed-up');
              } else {
                spawnParticles('ice', 30);
                playrateValue.classList.add('slow-down');
              }

              // PixiJS ridiculous effects based on action
              if (pixiEffects) {
                if (action === 'chaos') {
                  pixiEffects.chaos();
                } else if (action === 'reset') {
                  pixiEffects.reset();
                } else if (action === 'speedUp') {
                  pixiEffects.speedUp();
                } else if (action === 'slowDown') {
                  pixiEffects.slowDown();
                } else if (newRate > oldRate) {
                  pixiEffects.sparks(window.innerWidth / 2, window.innerHeight - 100, 0xff4400, 20);
                } else {
                  pixiEffects.sparks(window.innerWidth / 2, 100, 0x88ddff, 20);
                }
              }

              setTimeout(() => {
                playrateValue.classList.remove('speed-up', 'slow-down');
              }, 300);

              // Add to feed with username and avatar
              addToFeed(oldRate, newRate, username, action, avatarUrl);

              // Update session stats and combo with username
              updateSessionStats(oldRate, newRate, username);
              checkMilestones(newRate);

              // Store for REAPER sync
              pendingAction = { username, action, newRate, time: Date.now() };
              lastPlayrate = newRate;

              // Restart countdown if auto-reset is enabled and playrate changed from 1.0
              if (action !== 'reset' && autoResetEnabled && autoResetDelay > 0) {
                startCountdown(autoResetDelay);
              } else if (action === 'reset') {
                cancelCountdown();
              }
            }

            // Handle auto-reset event
            if (msg.type === 'autoReset') {
              cancelCountdown();
              triggerFlash();
              triggerShake();
              spawnParticles('ice', 50); // Cool down effect
              addToFeed(lastPlayrate, msg.data?.rate || 1.0, 'AUTO-RESET', 'reset');
              lastPlayrate = msg.data?.rate || 1.0;
            }

            // Handle config/init to get auto-reset settings
            if (msg.type === 'init' && msg.data?.config?.game?.autoReset) {
              const ar = msg.data.config.game.autoReset;
              autoResetEnabled = ar.enabled || false;
              autoResetDelay = ar.delaySeconds || 60;
            }

            if (msg.type === 'configUpdated' && msg.data?.game?.autoReset) {
              const ar = msg.data.game.autoReset;
              autoResetEnabled = ar.enabled || false;
              autoResetDelay = ar.delaySeconds || 60;
            }

            // ============ TEST MESSAGE HANDLERS ============

            // Test countdown
            if (msg.type === 'testCountdown' && msg.data?.seconds) {
              startCountdown(msg.data.seconds);
            }

            // Cancel test countdown
            if (msg.type === 'testCancelCountdown') {
              cancelCountdown();
            }

            // Test individual visual effects
            if (msg.type === 'testVisualEffect' && msg.data?.effect) {
              switch (msg.data.effect) {
                case 'shake':
                  triggerShake();
                  break;
                case 'flash':
                  triggerFlash();
                  break;
                case 'fireParticles':
                  spawnParticles('fire', 40);
                  break;
                case 'iceParticles':
                  spawnParticles('ice', 40);
                  break;
                case 'ambientFire':
                  startAmbientFire(0.7);
                  break;
                case 'stopAmbient':
                  stopAmbientFire();
                  break;
                // PixiJS effects
                case 'lightning':
                  if (pixiEffects) pixiEffects.lightning();
                  break;
                case 'lightningStorm':
                  if (pixiEffects) pixiEffects.lightningStorm(8);
                  break;
                case 'explosion':
                  if (pixiEffects) pixiEffects.explosion();
                  break;
                case 'chaos':
                  if (pixiEffects) pixiEffects.chaos();
                  break;
                case 'glitch':
                  if (pixiEffects) pixiEffects.glitch(1, 1000);
                  break;
              }
            }

            // Handle playrate changes from bot (fallback)
            if (msg.type === 'playrateChanged' && msg.data?.rate) {
              const oldRate = currentPlayrate;
              const newRate = msg.data.rate;

              // Update session stats and check milestones
              if (Math.abs(newRate - oldRate) >= 0.01) {
                updateSessionStats(oldRate, newRate);
                checkMilestones(newRate);
              }

              // Update display immediately for responsiveness
              currentPlayrate = newRate;
              updateDisplay();
            }
          } catch (e) {}
        };

        botWs.onclose = () => {
          console.log('Disconnected from bot, reconnecting in 5s...');
          setTimeout(connectToBot, 5000);
        };

        botWs.onerror = (err) => {
          console.error('Bot WebSocket error:', err);
        };
      } catch (e) {
        // WebSocket connection failed - bot probably not running
      }
    }

    function sendBpmToBot(bpm) {
      if (botWs && botWs.readyState === WebSocket.OPEN && bpm !== lastSentBpm) {
        botWs.send(JSON.stringify({ type: 'updateBpm', bpm: bpm }));
        lastSentBpm = bpm;
      }
    }

    // Connect to bot on load
    connectToBot();

    // Send BPM updates when detected from REAPER
    const originalWwrOnreply = wwr_onreply;
    wwr_onreply = function(results) {
      originalWwrOnreply(results);
      // Send BPM to bot if changed
      if (currentBpm > 0 && currentBpm !== lastSentBpm) {
        sendBpmToBot(currentBpm);
      }
    };
  </script>
</body>
</html>
